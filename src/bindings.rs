/* automatically generated by rust-bindgen 0.65.1 */

#[repr(C)]
#[derive(Copy, Clone, Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]
pub struct __BindgenBitfieldUnit<Storage> {
    storage: Storage,
}
impl<Storage> __BindgenBitfieldUnit<Storage> {
    #[inline]
    pub const fn new(storage: Storage) -> Self {
        Self { storage }
    }
}
impl<Storage> __BindgenBitfieldUnit<Storage>
where
    Storage: AsRef<[u8]> + AsMut<[u8]>,
{
    #[inline]
    pub fn get_bit(&self, index: usize) -> bool {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = self.storage.as_ref()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        byte & mask == mask
    }
    #[inline]
    pub fn set_bit(&mut self, index: usize, val: bool) {
        debug_assert!(index / 8 < self.storage.as_ref().len());
        let byte_index = index / 8;
        let byte = &mut self.storage.as_mut()[byte_index];
        let bit_index = if cfg!(target_endian = "big") {
            7 - (index % 8)
        } else {
            index % 8
        };
        let mask = 1 << bit_index;
        if val {
            *byte |= mask;
        } else {
            *byte &= !mask;
        }
    }
    #[inline]
    pub fn get(&self, bit_offset: usize, bit_width: u8) -> u64 {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        let mut val = 0;
        for i in 0..(bit_width as usize) {
            if self.get_bit(i + bit_offset) {
                let index = if cfg!(target_endian = "big") {
                    bit_width as usize - 1 - i
                } else {
                    i
                };
                val |= 1 << index;
            }
        }
        val
    }
    #[inline]
    pub fn set(&mut self, bit_offset: usize, bit_width: u8, val: u64) {
        debug_assert!(bit_width <= 64);
        debug_assert!(bit_offset / 8 < self.storage.as_ref().len());
        debug_assert!((bit_offset + (bit_width as usize)) / 8 <= self.storage.as_ref().len());
        for i in 0..(bit_width as usize) {
            let mask = 1 << i;
            let val_bit_is_set = val & mask == mask;
            let index = if cfg!(target_endian = "big") {
                bit_width as usize - 1 - i
            } else {
                i
            };
            self.set_bit(index + bit_offset, val_bit_is_set);
        }
    }
}
pub const __PRI_8_LENGTH_MODIFIER__: &[u8; 3usize] = b"hh\0";
pub const __PRI_64_LENGTH_MODIFIER__: &[u8; 3usize] = b"ll\0";
pub const __SCN_64_LENGTH_MODIFIER__: &[u8; 3usize] = b"ll\0";
pub const __PRI_MAX_LENGTH_MODIFIER__: &[u8; 2usize] = b"j\0";
pub const __SCN_MAX_LENGTH_MODIFIER__: &[u8; 2usize] = b"j\0";
pub const PRId8: &[u8; 4usize] = b"hhd\0";
pub const PRIi8: &[u8; 4usize] = b"hhi\0";
pub const PRIo8: &[u8; 4usize] = b"hho\0";
pub const PRIu8: &[u8; 4usize] = b"hhu\0";
pub const PRIx8: &[u8; 4usize] = b"hhx\0";
pub const PRIX8: &[u8; 4usize] = b"hhX\0";
pub const PRId16: &[u8; 3usize] = b"hd\0";
pub const PRIi16: &[u8; 3usize] = b"hi\0";
pub const PRIo16: &[u8; 3usize] = b"ho\0";
pub const PRIu16: &[u8; 3usize] = b"hu\0";
pub const PRIx16: &[u8; 3usize] = b"hx\0";
pub const PRIX16: &[u8; 3usize] = b"hX\0";
pub const PRId32: &[u8; 2usize] = b"d\0";
pub const PRIi32: &[u8; 2usize] = b"i\0";
pub const PRIo32: &[u8; 2usize] = b"o\0";
pub const PRIu32: &[u8; 2usize] = b"u\0";
pub const PRIx32: &[u8; 2usize] = b"x\0";
pub const PRIX32: &[u8; 2usize] = b"X\0";
pub const PRId64: &[u8; 4usize] = b"lld\0";
pub const PRIi64: &[u8; 4usize] = b"lli\0";
pub const PRIo64: &[u8; 4usize] = b"llo\0";
pub const PRIu64: &[u8; 4usize] = b"llu\0";
pub const PRIx64: &[u8; 4usize] = b"llx\0";
pub const PRIX64: &[u8; 4usize] = b"llX\0";
pub const PRIdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIoLEAST8: &[u8; 4usize] = b"hho\0";
pub const PRIuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIXLEAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIdLEAST16: &[u8; 3usize] = b"hd\0";
pub const PRIiLEAST16: &[u8; 3usize] = b"hi\0";
pub const PRIoLEAST16: &[u8; 3usize] = b"ho\0";
pub const PRIuLEAST16: &[u8; 3usize] = b"hu\0";
pub const PRIxLEAST16: &[u8; 3usize] = b"hx\0";
pub const PRIXLEAST16: &[u8; 3usize] = b"hX\0";
pub const PRIdLEAST32: &[u8; 2usize] = b"d\0";
pub const PRIiLEAST32: &[u8; 2usize] = b"i\0";
pub const PRIoLEAST32: &[u8; 2usize] = b"o\0";
pub const PRIuLEAST32: &[u8; 2usize] = b"u\0";
pub const PRIxLEAST32: &[u8; 2usize] = b"x\0";
pub const PRIXLEAST32: &[u8; 2usize] = b"X\0";
pub const PRIdLEAST64: &[u8; 4usize] = b"lld\0";
pub const PRIiLEAST64: &[u8; 4usize] = b"lli\0";
pub const PRIoLEAST64: &[u8; 4usize] = b"llo\0";
pub const PRIuLEAST64: &[u8; 4usize] = b"llu\0";
pub const PRIxLEAST64: &[u8; 4usize] = b"llx\0";
pub const PRIXLEAST64: &[u8; 4usize] = b"llX\0";
pub const PRIdFAST8: &[u8; 4usize] = b"hhd\0";
pub const PRIiFAST8: &[u8; 4usize] = b"hhi\0";
pub const PRIoFAST8: &[u8; 4usize] = b"hho\0";
pub const PRIuFAST8: &[u8; 4usize] = b"hhu\0";
pub const PRIxFAST8: &[u8; 4usize] = b"hhx\0";
pub const PRIXFAST8: &[u8; 4usize] = b"hhX\0";
pub const PRIdFAST16: &[u8; 3usize] = b"hd\0";
pub const PRIiFAST16: &[u8; 3usize] = b"hi\0";
pub const PRIoFAST16: &[u8; 3usize] = b"ho\0";
pub const PRIuFAST16: &[u8; 3usize] = b"hu\0";
pub const PRIxFAST16: &[u8; 3usize] = b"hx\0";
pub const PRIXFAST16: &[u8; 3usize] = b"hX\0";
pub const PRIdFAST32: &[u8; 2usize] = b"d\0";
pub const PRIiFAST32: &[u8; 2usize] = b"i\0";
pub const PRIoFAST32: &[u8; 2usize] = b"o\0";
pub const PRIuFAST32: &[u8; 2usize] = b"u\0";
pub const PRIxFAST32: &[u8; 2usize] = b"x\0";
pub const PRIXFAST32: &[u8; 2usize] = b"X\0";
pub const PRIdFAST64: &[u8; 4usize] = b"lld\0";
pub const PRIiFAST64: &[u8; 4usize] = b"lli\0";
pub const PRIoFAST64: &[u8; 4usize] = b"llo\0";
pub const PRIuFAST64: &[u8; 4usize] = b"llu\0";
pub const PRIxFAST64: &[u8; 4usize] = b"llx\0";
pub const PRIXFAST64: &[u8; 4usize] = b"llX\0";
pub const PRIdPTR: &[u8; 3usize] = b"ld\0";
pub const PRIiPTR: &[u8; 3usize] = b"li\0";
pub const PRIoPTR: &[u8; 3usize] = b"lo\0";
pub const PRIuPTR: &[u8; 3usize] = b"lu\0";
pub const PRIxPTR: &[u8; 3usize] = b"lx\0";
pub const PRIXPTR: &[u8; 3usize] = b"lX\0";
pub const PRIdMAX: &[u8; 3usize] = b"jd\0";
pub const PRIiMAX: &[u8; 3usize] = b"ji\0";
pub const PRIoMAX: &[u8; 3usize] = b"jo\0";
pub const PRIuMAX: &[u8; 3usize] = b"ju\0";
pub const PRIxMAX: &[u8; 3usize] = b"jx\0";
pub const PRIXMAX: &[u8; 3usize] = b"jX\0";
pub const SCNd8: &[u8; 4usize] = b"hhd\0";
pub const SCNi8: &[u8; 4usize] = b"hhi\0";
pub const SCNo8: &[u8; 4usize] = b"hho\0";
pub const SCNu8: &[u8; 4usize] = b"hhu\0";
pub const SCNx8: &[u8; 4usize] = b"hhx\0";
pub const SCNd16: &[u8; 3usize] = b"hd\0";
pub const SCNi16: &[u8; 3usize] = b"hi\0";
pub const SCNo16: &[u8; 3usize] = b"ho\0";
pub const SCNu16: &[u8; 3usize] = b"hu\0";
pub const SCNx16: &[u8; 3usize] = b"hx\0";
pub const SCNd32: &[u8; 2usize] = b"d\0";
pub const SCNi32: &[u8; 2usize] = b"i\0";
pub const SCNo32: &[u8; 2usize] = b"o\0";
pub const SCNu32: &[u8; 2usize] = b"u\0";
pub const SCNx32: &[u8; 2usize] = b"x\0";
pub const SCNd64: &[u8; 4usize] = b"lld\0";
pub const SCNi64: &[u8; 4usize] = b"lli\0";
pub const SCNo64: &[u8; 4usize] = b"llo\0";
pub const SCNu64: &[u8; 4usize] = b"llu\0";
pub const SCNx64: &[u8; 4usize] = b"llx\0";
pub const SCNdLEAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNiLEAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNoLEAST8: &[u8; 4usize] = b"hho\0";
pub const SCNuLEAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNxLEAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNdLEAST16: &[u8; 3usize] = b"hd\0";
pub const SCNiLEAST16: &[u8; 3usize] = b"hi\0";
pub const SCNoLEAST16: &[u8; 3usize] = b"ho\0";
pub const SCNuLEAST16: &[u8; 3usize] = b"hu\0";
pub const SCNxLEAST16: &[u8; 3usize] = b"hx\0";
pub const SCNdLEAST32: &[u8; 2usize] = b"d\0";
pub const SCNiLEAST32: &[u8; 2usize] = b"i\0";
pub const SCNoLEAST32: &[u8; 2usize] = b"o\0";
pub const SCNuLEAST32: &[u8; 2usize] = b"u\0";
pub const SCNxLEAST32: &[u8; 2usize] = b"x\0";
pub const SCNdLEAST64: &[u8; 4usize] = b"lld\0";
pub const SCNiLEAST64: &[u8; 4usize] = b"lli\0";
pub const SCNoLEAST64: &[u8; 4usize] = b"llo\0";
pub const SCNuLEAST64: &[u8; 4usize] = b"llu\0";
pub const SCNxLEAST64: &[u8; 4usize] = b"llx\0";
pub const SCNdFAST8: &[u8; 4usize] = b"hhd\0";
pub const SCNiFAST8: &[u8; 4usize] = b"hhi\0";
pub const SCNoFAST8: &[u8; 4usize] = b"hho\0";
pub const SCNuFAST8: &[u8; 4usize] = b"hhu\0";
pub const SCNxFAST8: &[u8; 4usize] = b"hhx\0";
pub const SCNdFAST16: &[u8; 3usize] = b"hd\0";
pub const SCNiFAST16: &[u8; 3usize] = b"hi\0";
pub const SCNoFAST16: &[u8; 3usize] = b"ho\0";
pub const SCNuFAST16: &[u8; 3usize] = b"hu\0";
pub const SCNxFAST16: &[u8; 3usize] = b"hx\0";
pub const SCNdFAST32: &[u8; 2usize] = b"d\0";
pub const SCNiFAST32: &[u8; 2usize] = b"i\0";
pub const SCNoFAST32: &[u8; 2usize] = b"o\0";
pub const SCNuFAST32: &[u8; 2usize] = b"u\0";
pub const SCNxFAST32: &[u8; 2usize] = b"x\0";
pub const SCNdFAST64: &[u8; 4usize] = b"lld\0";
pub const SCNiFAST64: &[u8; 4usize] = b"lli\0";
pub const SCNoFAST64: &[u8; 4usize] = b"llo\0";
pub const SCNuFAST64: &[u8; 4usize] = b"llu\0";
pub const SCNxFAST64: &[u8; 4usize] = b"llx\0";
pub const SCNdPTR: &[u8; 3usize] = b"ld\0";
pub const SCNiPTR: &[u8; 3usize] = b"li\0";
pub const SCNoPTR: &[u8; 3usize] = b"lo\0";
pub const SCNuPTR: &[u8; 3usize] = b"lu\0";
pub const SCNxPTR: &[u8; 3usize] = b"lx\0";
pub const SCNdMAX: &[u8; 3usize] = b"jd\0";
pub const SCNiMAX: &[u8; 3usize] = b"ji\0";
pub const SCNoMAX: &[u8; 3usize] = b"jo\0";
pub const SCNuMAX: &[u8; 3usize] = b"ju\0";
pub const SCNxMAX: &[u8; 3usize] = b"jx\0";
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14usize] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __API_TO_BE_DEPRECATED: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_IOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_MACCATALYST: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_WATCHOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_TVOS: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_DRIVERKIT: u32 = 100000;
pub const __API_TO_BE_DEPRECATED_XROS: u32 = 100000;
pub const __MAC_10_0: u32 = 1000;
pub const __MAC_10_1: u32 = 1010;
pub const __MAC_10_2: u32 = 1020;
pub const __MAC_10_3: u32 = 1030;
pub const __MAC_10_4: u32 = 1040;
pub const __MAC_10_5: u32 = 1050;
pub const __MAC_10_6: u32 = 1060;
pub const __MAC_10_7: u32 = 1070;
pub const __MAC_10_8: u32 = 1080;
pub const __MAC_10_9: u32 = 1090;
pub const __MAC_10_10: u32 = 101000;
pub const __MAC_10_10_2: u32 = 101002;
pub const __MAC_10_10_3: u32 = 101003;
pub const __MAC_10_11: u32 = 101100;
pub const __MAC_10_11_2: u32 = 101102;
pub const __MAC_10_11_3: u32 = 101103;
pub const __MAC_10_11_4: u32 = 101104;
pub const __MAC_10_12: u32 = 101200;
pub const __MAC_10_12_1: u32 = 101201;
pub const __MAC_10_12_2: u32 = 101202;
pub const __MAC_10_12_4: u32 = 101204;
pub const __MAC_10_13: u32 = 101300;
pub const __MAC_10_13_1: u32 = 101301;
pub const __MAC_10_13_2: u32 = 101302;
pub const __MAC_10_13_4: u32 = 101304;
pub const __MAC_10_14: u32 = 101400;
pub const __MAC_10_14_1: u32 = 101401;
pub const __MAC_10_14_4: u32 = 101404;
pub const __MAC_10_14_5: u32 = 101405;
pub const __MAC_10_14_6: u32 = 101406;
pub const __MAC_10_15: u32 = 101500;
pub const __MAC_10_15_1: u32 = 101501;
pub const __MAC_10_15_4: u32 = 101504;
pub const __MAC_10_16: u32 = 101600;
pub const __MAC_11_0: u32 = 110000;
pub const __MAC_11_1: u32 = 110100;
pub const __MAC_11_3: u32 = 110300;
pub const __MAC_11_4: u32 = 110400;
pub const __MAC_11_5: u32 = 110500;
pub const __MAC_11_6: u32 = 110600;
pub const __MAC_12_0: u32 = 120000;
pub const __MAC_12_1: u32 = 120100;
pub const __MAC_12_2: u32 = 120200;
pub const __MAC_12_3: u32 = 120300;
pub const __MAC_12_4: u32 = 120400;
pub const __MAC_12_5: u32 = 120500;
pub const __MAC_13_0: u32 = 130000;
pub const __MAC_13_1: u32 = 130100;
pub const __MAC_13_2: u32 = 130200;
pub const __MAC_13_3: u32 = 130300;
pub const __MAC_13_4: u32 = 130400;
pub const __MAC_14_0: u32 = 140000;
pub const __IPHONE_2_0: u32 = 20000;
pub const __IPHONE_2_1: u32 = 20100;
pub const __IPHONE_2_2: u32 = 20200;
pub const __IPHONE_3_0: u32 = 30000;
pub const __IPHONE_3_1: u32 = 30100;
pub const __IPHONE_3_2: u32 = 30200;
pub const __IPHONE_4_0: u32 = 40000;
pub const __IPHONE_4_1: u32 = 40100;
pub const __IPHONE_4_2: u32 = 40200;
pub const __IPHONE_4_3: u32 = 40300;
pub const __IPHONE_5_0: u32 = 50000;
pub const __IPHONE_5_1: u32 = 50100;
pub const __IPHONE_6_0: u32 = 60000;
pub const __IPHONE_6_1: u32 = 60100;
pub const __IPHONE_7_0: u32 = 70000;
pub const __IPHONE_7_1: u32 = 70100;
pub const __IPHONE_8_0: u32 = 80000;
pub const __IPHONE_8_1: u32 = 80100;
pub const __IPHONE_8_2: u32 = 80200;
pub const __IPHONE_8_3: u32 = 80300;
pub const __IPHONE_8_4: u32 = 80400;
pub const __IPHONE_9_0: u32 = 90000;
pub const __IPHONE_9_1: u32 = 90100;
pub const __IPHONE_9_2: u32 = 90200;
pub const __IPHONE_9_3: u32 = 90300;
pub const __IPHONE_10_0: u32 = 100000;
pub const __IPHONE_10_1: u32 = 100100;
pub const __IPHONE_10_2: u32 = 100200;
pub const __IPHONE_10_3: u32 = 100300;
pub const __IPHONE_11_0: u32 = 110000;
pub const __IPHONE_11_1: u32 = 110100;
pub const __IPHONE_11_2: u32 = 110200;
pub const __IPHONE_11_3: u32 = 110300;
pub const __IPHONE_11_4: u32 = 110400;
pub const __IPHONE_12_0: u32 = 120000;
pub const __IPHONE_12_1: u32 = 120100;
pub const __IPHONE_12_2: u32 = 120200;
pub const __IPHONE_12_3: u32 = 120300;
pub const __IPHONE_12_4: u32 = 120400;
pub const __IPHONE_13_0: u32 = 130000;
pub const __IPHONE_13_1: u32 = 130100;
pub const __IPHONE_13_2: u32 = 130200;
pub const __IPHONE_13_3: u32 = 130300;
pub const __IPHONE_13_4: u32 = 130400;
pub const __IPHONE_13_5: u32 = 130500;
pub const __IPHONE_13_6: u32 = 130600;
pub const __IPHONE_13_7: u32 = 130700;
pub const __IPHONE_14_0: u32 = 140000;
pub const __IPHONE_14_1: u32 = 140100;
pub const __IPHONE_14_2: u32 = 140200;
pub const __IPHONE_14_3: u32 = 140300;
pub const __IPHONE_14_5: u32 = 140500;
pub const __IPHONE_14_4: u32 = 140400;
pub const __IPHONE_14_6: u32 = 140600;
pub const __IPHONE_14_7: u32 = 140700;
pub const __IPHONE_14_8: u32 = 140800;
pub const __IPHONE_15_0: u32 = 150000;
pub const __IPHONE_15_1: u32 = 150100;
pub const __IPHONE_15_2: u32 = 150200;
pub const __IPHONE_15_3: u32 = 150300;
pub const __IPHONE_15_4: u32 = 150400;
pub const __IPHONE_15_5: u32 = 150500;
pub const __IPHONE_15_6: u32 = 150600;
pub const __IPHONE_16_0: u32 = 160000;
pub const __IPHONE_16_1: u32 = 160100;
pub const __IPHONE_16_2: u32 = 160200;
pub const __IPHONE_16_3: u32 = 160300;
pub const __IPHONE_16_4: u32 = 160400;
pub const __IPHONE_16_5: u32 = 160500;
pub const __IPHONE_17_0: u32 = 170000;
pub const __WATCHOS_1_0: u32 = 10000;
pub const __WATCHOS_2_0: u32 = 20000;
pub const __WATCHOS_2_1: u32 = 20100;
pub const __WATCHOS_2_2: u32 = 20200;
pub const __WATCHOS_3_0: u32 = 30000;
pub const __WATCHOS_3_1: u32 = 30100;
pub const __WATCHOS_3_1_1: u32 = 30101;
pub const __WATCHOS_3_2: u32 = 30200;
pub const __WATCHOS_4_0: u32 = 40000;
pub const __WATCHOS_4_1: u32 = 40100;
pub const __WATCHOS_4_2: u32 = 40200;
pub const __WATCHOS_4_3: u32 = 40300;
pub const __WATCHOS_5_0: u32 = 50000;
pub const __WATCHOS_5_1: u32 = 50100;
pub const __WATCHOS_5_2: u32 = 50200;
pub const __WATCHOS_5_3: u32 = 50300;
pub const __WATCHOS_6_0: u32 = 60000;
pub const __WATCHOS_6_1: u32 = 60100;
pub const __WATCHOS_6_2: u32 = 60200;
pub const __WATCHOS_7_0: u32 = 70000;
pub const __WATCHOS_7_1: u32 = 70100;
pub const __WATCHOS_7_2: u32 = 70200;
pub const __WATCHOS_7_3: u32 = 70300;
pub const __WATCHOS_7_4: u32 = 70400;
pub const __WATCHOS_7_5: u32 = 70500;
pub const __WATCHOS_7_6: u32 = 70600;
pub const __WATCHOS_8_0: u32 = 80000;
pub const __WATCHOS_8_1: u32 = 80100;
pub const __WATCHOS_8_3: u32 = 80300;
pub const __WATCHOS_8_4: u32 = 80400;
pub const __WATCHOS_8_5: u32 = 80500;
pub const __WATCHOS_8_6: u32 = 80600;
pub const __WATCHOS_8_7: u32 = 80700;
pub const __WATCHOS_9_0: u32 = 90000;
pub const __WATCHOS_9_1: u32 = 90100;
pub const __WATCHOS_9_2: u32 = 90200;
pub const __WATCHOS_9_3: u32 = 90300;
pub const __WATCHOS_9_4: u32 = 90400;
pub const __WATCHOS_9_5: u32 = 90500;
pub const __WATCHOS_10_0: u32 = 100000;
pub const __TVOS_9_0: u32 = 90000;
pub const __TVOS_9_1: u32 = 90100;
pub const __TVOS_9_2: u32 = 90200;
pub const __TVOS_10_0: u32 = 100000;
pub const __TVOS_10_0_1: u32 = 100001;
pub const __TVOS_10_1: u32 = 100100;
pub const __TVOS_10_2: u32 = 100200;
pub const __TVOS_11_0: u32 = 110000;
pub const __TVOS_11_1: u32 = 110100;
pub const __TVOS_11_2: u32 = 110200;
pub const __TVOS_11_3: u32 = 110300;
pub const __TVOS_11_4: u32 = 110400;
pub const __TVOS_12_0: u32 = 120000;
pub const __TVOS_12_1: u32 = 120100;
pub const __TVOS_12_2: u32 = 120200;
pub const __TVOS_12_3: u32 = 120300;
pub const __TVOS_12_4: u32 = 120400;
pub const __TVOS_13_0: u32 = 130000;
pub const __TVOS_13_2: u32 = 130200;
pub const __TVOS_13_3: u32 = 130300;
pub const __TVOS_13_4: u32 = 130400;
pub const __TVOS_14_0: u32 = 140000;
pub const __TVOS_14_1: u32 = 140100;
pub const __TVOS_14_2: u32 = 140200;
pub const __TVOS_14_3: u32 = 140300;
pub const __TVOS_14_5: u32 = 140500;
pub const __TVOS_14_6: u32 = 140600;
pub const __TVOS_14_7: u32 = 140700;
pub const __TVOS_15_0: u32 = 150000;
pub const __TVOS_15_1: u32 = 150100;
pub const __TVOS_15_2: u32 = 150200;
pub const __TVOS_15_3: u32 = 150300;
pub const __TVOS_15_4: u32 = 150400;
pub const __TVOS_15_5: u32 = 150500;
pub const __TVOS_15_6: u32 = 150600;
pub const __TVOS_16_0: u32 = 160000;
pub const __TVOS_16_1: u32 = 160100;
pub const __TVOS_16_2: u32 = 160200;
pub const __TVOS_16_3: u32 = 160300;
pub const __TVOS_16_4: u32 = 160400;
pub const __TVOS_16_5: u32 = 160500;
pub const __TVOS_17_0: u32 = 170000;
pub const __BRIDGEOS_2_0: u32 = 20000;
pub const __BRIDGEOS_3_0: u32 = 30000;
pub const __BRIDGEOS_3_1: u32 = 30100;
pub const __BRIDGEOS_3_4: u32 = 30400;
pub const __BRIDGEOS_4_0: u32 = 40000;
pub const __BRIDGEOS_4_1: u32 = 40100;
pub const __BRIDGEOS_5_0: u32 = 50000;
pub const __BRIDGEOS_5_1: u32 = 50100;
pub const __BRIDGEOS_5_3: u32 = 50300;
pub const __BRIDGEOS_6_0: u32 = 60000;
pub const __BRIDGEOS_6_2: u32 = 60200;
pub const __BRIDGEOS_6_4: u32 = 60400;
pub const __BRIDGEOS_6_5: u32 = 60500;
pub const __BRIDGEOS_6_6: u32 = 60600;
pub const __BRIDGEOS_7_0: u32 = 70000;
pub const __BRIDGEOS_7_1: u32 = 70100;
pub const __BRIDGEOS_7_2: u32 = 70200;
pub const __BRIDGEOS_7_3: u32 = 70300;
pub const __BRIDGEOS_7_4: u32 = 70400;
pub const __BRIDGEOS_8_0: u32 = 80000;
pub const __DRIVERKIT_19_0: u32 = 190000;
pub const __DRIVERKIT_20_0: u32 = 200000;
pub const __DRIVERKIT_21_0: u32 = 210000;
pub const __DRIVERKIT_22_0: u32 = 220000;
pub const __DRIVERKIT_22_4: u32 = 220400;
pub const __DRIVERKIT_22_5: u32 = 220500;
pub const __DRIVERKIT_23_0: u32 = 230000;
pub const __XROS_1_0: u32 = 10000;
pub const MAC_OS_X_VERSION_10_0: u32 = 1000;
pub const MAC_OS_X_VERSION_10_1: u32 = 1010;
pub const MAC_OS_X_VERSION_10_2: u32 = 1020;
pub const MAC_OS_X_VERSION_10_3: u32 = 1030;
pub const MAC_OS_X_VERSION_10_4: u32 = 1040;
pub const MAC_OS_X_VERSION_10_5: u32 = 1050;
pub const MAC_OS_X_VERSION_10_6: u32 = 1060;
pub const MAC_OS_X_VERSION_10_7: u32 = 1070;
pub const MAC_OS_X_VERSION_10_8: u32 = 1080;
pub const MAC_OS_X_VERSION_10_9: u32 = 1090;
pub const MAC_OS_X_VERSION_10_10: u32 = 101000;
pub const MAC_OS_X_VERSION_10_10_2: u32 = 101002;
pub const MAC_OS_X_VERSION_10_10_3: u32 = 101003;
pub const MAC_OS_X_VERSION_10_11: u32 = 101100;
pub const MAC_OS_X_VERSION_10_11_2: u32 = 101102;
pub const MAC_OS_X_VERSION_10_11_3: u32 = 101103;
pub const MAC_OS_X_VERSION_10_11_4: u32 = 101104;
pub const MAC_OS_X_VERSION_10_12: u32 = 101200;
pub const MAC_OS_X_VERSION_10_12_1: u32 = 101201;
pub const MAC_OS_X_VERSION_10_12_2: u32 = 101202;
pub const MAC_OS_X_VERSION_10_12_4: u32 = 101204;
pub const MAC_OS_X_VERSION_10_13: u32 = 101300;
pub const MAC_OS_X_VERSION_10_13_1: u32 = 101301;
pub const MAC_OS_X_VERSION_10_13_2: u32 = 101302;
pub const MAC_OS_X_VERSION_10_13_4: u32 = 101304;
pub const MAC_OS_X_VERSION_10_14: u32 = 101400;
pub const MAC_OS_X_VERSION_10_14_1: u32 = 101401;
pub const MAC_OS_X_VERSION_10_14_4: u32 = 101404;
pub const MAC_OS_X_VERSION_10_14_5: u32 = 101405;
pub const MAC_OS_X_VERSION_10_14_6: u32 = 101406;
pub const MAC_OS_X_VERSION_10_15: u32 = 101500;
pub const MAC_OS_X_VERSION_10_15_1: u32 = 101501;
pub const MAC_OS_X_VERSION_10_15_4: u32 = 101504;
pub const MAC_OS_X_VERSION_10_16: u32 = 101600;
pub const MAC_OS_VERSION_11_0: u32 = 110000;
pub const MAC_OS_VERSION_11_1: u32 = 110100;
pub const MAC_OS_VERSION_11_3: u32 = 110300;
pub const MAC_OS_VERSION_11_4: u32 = 110400;
pub const MAC_OS_VERSION_11_5: u32 = 110500;
pub const MAC_OS_VERSION_11_6: u32 = 110600;
pub const MAC_OS_VERSION_12_0: u32 = 120000;
pub const MAC_OS_VERSION_12_1: u32 = 120100;
pub const MAC_OS_VERSION_12_2: u32 = 120200;
pub const MAC_OS_VERSION_12_3: u32 = 120300;
pub const MAC_OS_VERSION_12_4: u32 = 120400;
pub const MAC_OS_VERSION_12_5: u32 = 120500;
pub const MAC_OS_VERSION_13_0: u32 = 130000;
pub const MAC_OS_VERSION_13_1: u32 = 130100;
pub const MAC_OS_VERSION_13_2: u32 = 130200;
pub const MAC_OS_VERSION_13_3: u32 = 130300;
pub const MAC_OS_VERSION_13_4: u32 = 130400;
pub const MAC_OS_VERSION_14_0: u32 = 140000;
pub const __MAC_OS_X_VERSION_MAX_ALLOWED: u32 = 140000;
pub const __ENABLE_LEGACY_MAC_AVAILABILITY: u32 = 1;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const __DARWIN_WCHAR_MIN: i32 = -2147483648;
pub const _FORTIFY_SOURCE: u32 = 2;
pub const __WORDSIZE: u32 = 64;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_NSIG: u32 = 32;
pub const NSIG: u32 = 32;
pub const _ARM_SIGNAL_: u32 = 1;
pub const SIGHUP: u32 = 1;
pub const SIGINT: u32 = 2;
pub const SIGQUIT: u32 = 3;
pub const SIGILL: u32 = 4;
pub const SIGTRAP: u32 = 5;
pub const SIGABRT: u32 = 6;
pub const SIGIOT: u32 = 6;
pub const SIGEMT: u32 = 7;
pub const SIGFPE: u32 = 8;
pub const SIGKILL: u32 = 9;
pub const SIGBUS: u32 = 10;
pub const SIGSEGV: u32 = 11;
pub const SIGSYS: u32 = 12;
pub const SIGPIPE: u32 = 13;
pub const SIGALRM: u32 = 14;
pub const SIGTERM: u32 = 15;
pub const SIGURG: u32 = 16;
pub const SIGSTOP: u32 = 17;
pub const SIGTSTP: u32 = 18;
pub const SIGCONT: u32 = 19;
pub const SIGCHLD: u32 = 20;
pub const SIGTTIN: u32 = 21;
pub const SIGTTOU: u32 = 22;
pub const SIGIO: u32 = 23;
pub const SIGXCPU: u32 = 24;
pub const SIGXFSZ: u32 = 25;
pub const SIGVTALRM: u32 = 26;
pub const SIGPROF: u32 = 27;
pub const SIGWINCH: u32 = 28;
pub const SIGINFO: u32 = 29;
pub const SIGUSR1: u32 = 30;
pub const SIGUSR2: u32 = 31;
pub const __DARWIN_OPAQUE_ARM_THREAD_STATE64: u32 = 0;
pub const SIGEV_NONE: u32 = 0;
pub const SIGEV_SIGNAL: u32 = 1;
pub const SIGEV_THREAD: u32 = 3;
pub const ILL_NOOP: u32 = 0;
pub const ILL_ILLOPC: u32 = 1;
pub const ILL_ILLTRP: u32 = 2;
pub const ILL_PRVOPC: u32 = 3;
pub const ILL_ILLOPN: u32 = 4;
pub const ILL_ILLADR: u32 = 5;
pub const ILL_PRVREG: u32 = 6;
pub const ILL_COPROC: u32 = 7;
pub const ILL_BADSTK: u32 = 8;
pub const FPE_NOOP: u32 = 0;
pub const FPE_FLTDIV: u32 = 1;
pub const FPE_FLTOVF: u32 = 2;
pub const FPE_FLTUND: u32 = 3;
pub const FPE_FLTRES: u32 = 4;
pub const FPE_FLTINV: u32 = 5;
pub const FPE_FLTSUB: u32 = 6;
pub const FPE_INTDIV: u32 = 7;
pub const FPE_INTOVF: u32 = 8;
pub const SEGV_NOOP: u32 = 0;
pub const SEGV_MAPERR: u32 = 1;
pub const SEGV_ACCERR: u32 = 2;
pub const BUS_NOOP: u32 = 0;
pub const BUS_ADRALN: u32 = 1;
pub const BUS_ADRERR: u32 = 2;
pub const BUS_OBJERR: u32 = 3;
pub const TRAP_BRKPT: u32 = 1;
pub const TRAP_TRACE: u32 = 2;
pub const CLD_NOOP: u32 = 0;
pub const CLD_EXITED: u32 = 1;
pub const CLD_KILLED: u32 = 2;
pub const CLD_DUMPED: u32 = 3;
pub const CLD_TRAPPED: u32 = 4;
pub const CLD_STOPPED: u32 = 5;
pub const CLD_CONTINUED: u32 = 6;
pub const POLL_IN: u32 = 1;
pub const POLL_OUT: u32 = 2;
pub const POLL_MSG: u32 = 3;
pub const POLL_ERR: u32 = 4;
pub const POLL_PRI: u32 = 5;
pub const POLL_HUP: u32 = 6;
pub const SA_ONSTACK: u32 = 1;
pub const SA_RESTART: u32 = 2;
pub const SA_RESETHAND: u32 = 4;
pub const SA_NOCLDSTOP: u32 = 8;
pub const SA_NODEFER: u32 = 16;
pub const SA_NOCLDWAIT: u32 = 32;
pub const SA_SIGINFO: u32 = 64;
pub const SA_USERTRAMP: u32 = 256;
pub const SA_64REGSET: u32 = 512;
pub const SA_USERSPACE_MASK: u32 = 127;
pub const SIG_BLOCK: u32 = 1;
pub const SIG_UNBLOCK: u32 = 2;
pub const SIG_SETMASK: u32 = 3;
pub const SI_USER: u32 = 65537;
pub const SI_QUEUE: u32 = 65538;
pub const SI_TIMER: u32 = 65539;
pub const SI_ASYNCIO: u32 = 65540;
pub const SI_MESGQ: u32 = 65541;
pub const SS_ONSTACK: u32 = 1;
pub const SS_DISABLE: u32 = 4;
pub const MINSIGSTKSZ: u32 = 32768;
pub const SIGSTKSZ: u32 = 131072;
pub const SV_ONSTACK: u32 = 1;
pub const SV_INTERRUPT: u32 = 2;
pub const SV_RESETHAND: u32 = 4;
pub const SV_NODEFER: u32 = 16;
pub const SV_NOCLDSTOP: u32 = 8;
pub const SV_SIGINFO: u32 = 64;
pub const PRIO_PROCESS: u32 = 0;
pub const PRIO_PGRP: u32 = 1;
pub const PRIO_USER: u32 = 2;
pub const PRIO_DARWIN_THREAD: u32 = 3;
pub const PRIO_DARWIN_PROCESS: u32 = 4;
pub const PRIO_MIN: i32 = -20;
pub const PRIO_MAX: u32 = 20;
pub const PRIO_DARWIN_BG: u32 = 4096;
pub const PRIO_DARWIN_NONUI: u32 = 4097;
pub const RUSAGE_SELF: u32 = 0;
pub const RUSAGE_CHILDREN: i32 = -1;
pub const RUSAGE_INFO_V0: u32 = 0;
pub const RUSAGE_INFO_V1: u32 = 1;
pub const RUSAGE_INFO_V2: u32 = 2;
pub const RUSAGE_INFO_V3: u32 = 3;
pub const RUSAGE_INFO_V4: u32 = 4;
pub const RUSAGE_INFO_V5: u32 = 5;
pub const RUSAGE_INFO_V6: u32 = 6;
pub const RUSAGE_INFO_CURRENT: u32 = 6;
pub const RU_PROC_RUNS_RESLIDE: u32 = 1;
pub const RLIMIT_CPU: u32 = 0;
pub const RLIMIT_FSIZE: u32 = 1;
pub const RLIMIT_DATA: u32 = 2;
pub const RLIMIT_STACK: u32 = 3;
pub const RLIMIT_CORE: u32 = 4;
pub const RLIMIT_AS: u32 = 5;
pub const RLIMIT_RSS: u32 = 5;
pub const RLIMIT_MEMLOCK: u32 = 6;
pub const RLIMIT_NPROC: u32 = 7;
pub const RLIMIT_NOFILE: u32 = 8;
pub const RLIM_NLIMITS: u32 = 9;
pub const _RLIMIT_POSIX_FLAG: u32 = 4096;
pub const RLIMIT_WAKEUPS_MONITOR: u32 = 1;
pub const RLIMIT_CPU_USAGE_MONITOR: u32 = 2;
pub const RLIMIT_THREAD_CPULIMITS: u32 = 3;
pub const RLIMIT_FOOTPRINT_INTERVAL: u32 = 4;
pub const WAKEMON_ENABLE: u32 = 1;
pub const WAKEMON_DISABLE: u32 = 2;
pub const WAKEMON_GET_PARAMS: u32 = 4;
pub const WAKEMON_SET_DEFAULTS: u32 = 8;
pub const WAKEMON_MAKE_FATAL: u32 = 16;
pub const CPUMON_MAKE_FATAL: u32 = 4096;
pub const FOOTPRINT_INTERVAL_RESET: u32 = 1;
pub const IOPOL_TYPE_DISK: u32 = 0;
pub const IOPOL_TYPE_VFS_ATIME_UPDATES: u32 = 2;
pub const IOPOL_TYPE_VFS_MATERIALIZE_DATALESS_FILES: u32 = 3;
pub const IOPOL_TYPE_VFS_STATFS_NO_DATA_VOLUME: u32 = 4;
pub const IOPOL_TYPE_VFS_TRIGGER_RESOLVE: u32 = 5;
pub const IOPOL_TYPE_VFS_IGNORE_CONTENT_PROTECTION: u32 = 6;
pub const IOPOL_TYPE_VFS_IGNORE_PERMISSIONS: u32 = 7;
pub const IOPOL_TYPE_VFS_SKIP_MTIME_UPDATE: u32 = 8;
pub const IOPOL_TYPE_VFS_ALLOW_LOW_SPACE_WRITES: u32 = 9;
pub const IOPOL_TYPE_VFS_DISALLOW_RW_FOR_O_EVTONLY: u32 = 10;
pub const IOPOL_SCOPE_PROCESS: u32 = 0;
pub const IOPOL_SCOPE_THREAD: u32 = 1;
pub const IOPOL_SCOPE_DARWIN_BG: u32 = 2;
pub const IOPOL_DEFAULT: u32 = 0;
pub const IOPOL_IMPORTANT: u32 = 1;
pub const IOPOL_PASSIVE: u32 = 2;
pub const IOPOL_THROTTLE: u32 = 3;
pub const IOPOL_UTILITY: u32 = 4;
pub const IOPOL_STANDARD: u32 = 5;
pub const IOPOL_APPLICATION: u32 = 5;
pub const IOPOL_NORMAL: u32 = 1;
pub const IOPOL_ATIME_UPDATES_DEFAULT: u32 = 0;
pub const IOPOL_ATIME_UPDATES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_DEFAULT: u32 = 0;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_OFF: u32 = 1;
pub const IOPOL_MATERIALIZE_DATALESS_FILES_ON: u32 = 2;
pub const IOPOL_VFS_STATFS_NO_DATA_VOLUME_DEFAULT: u32 = 0;
pub const IOPOL_VFS_STATFS_FORCE_NO_DATA_VOLUME: u32 = 1;
pub const IOPOL_VFS_TRIGGER_RESOLVE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_TRIGGER_RESOLVE_OFF: u32 = 1;
pub const IOPOL_VFS_CONTENT_PROTECTION_DEFAULT: u32 = 0;
pub const IOPOL_VFS_CONTENT_PROTECTION_IGNORE: u32 = 1;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_OFF: u32 = 0;
pub const IOPOL_VFS_IGNORE_PERMISSIONS_ON: u32 = 1;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_OFF: u32 = 0;
pub const IOPOL_VFS_SKIP_MTIME_UPDATE_ON: u32 = 1;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_OFF: u32 = 0;
pub const IOPOL_VFS_ALLOW_LOW_SPACE_WRITES_ON: u32 = 1;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_DEFAULT: u32 = 0;
pub const IOPOL_VFS_DISALLOW_RW_FOR_O_EVTONLY_ON: u32 = 1;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_DEFAULT: u32 = 0;
pub const IOPOL_VFS_NOCACHE_WRITE_FS_BLKSIZE_ON: u32 = 1;
pub const WNOHANG: u32 = 1;
pub const WUNTRACED: u32 = 2;
pub const WCOREFLAG: u32 = 128;
pub const _WSTOPPED: u32 = 127;
pub const WEXITED: u32 = 4;
pub const WSTOPPED: u32 = 8;
pub const WCONTINUED: u32 = 16;
pub const WNOWAIT: u32 = 32;
pub const WAIT_ANY: i32 = -1;
pub const WAIT_MYPGRP: u32 = 0;
pub const _QUAD_HIGHWORD: u32 = 1;
pub const _QUAD_LOWWORD: u32 = 0;
pub const __DARWIN_LITTLE_ENDIAN: u32 = 1234;
pub const __DARWIN_BIG_ENDIAN: u32 = 4321;
pub const __DARWIN_PDP_ENDIAN: u32 = 3412;
pub const __DARWIN_BYTE_ORDER: u32 = 1234;
pub const LITTLE_ENDIAN: u32 = 1234;
pub const BIG_ENDIAN: u32 = 4321;
pub const PDP_ENDIAN: u32 = 3412;
pub const BYTE_ORDER: u32 = 1234;
pub const EXIT_FAILURE: u32 = 1;
pub const EXIT_SUCCESS: u32 = 0;
pub const RAND_MAX: u32 = 2147483647;
pub const LIBBLADERF_API_VERSION: u32 = 33882112;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const BLADERF_DESCRIPTION_LENGTH: u32 = 33;
pub const BLADERF_SERIAL_LENGTH: u32 = 33;
pub const BLADERF_DIRECTION_MASK: u32 = 1;
pub const BLADERF_PRIuFREQ: &[u8; 4usize] = b"llu\0";
pub const BLADERF_PRIxFREQ: &[u8; 4usize] = b"llx\0";
pub const BLADERF_SCNuFREQ: &[u8; 4usize] = b"llu\0";
pub const BLADERF_SCNxFREQ: &[u8; 4usize] = b"llx\0";
pub const BLADERF_PRIuTS: &[u8; 4usize] = b"llu\0";
pub const BLADERF_PRIxTS: &[u8; 4usize] = b"llx\0";
pub const BLADERF_SCNuTS: &[u8; 4usize] = b"llu\0";
pub const BLADERF_SCNxTS: &[u8; 4usize] = b"llx\0";
pub const BLADERF_META_STATUS_OVERRUN: u32 = 1;
pub const BLADERF_META_STATUS_UNDERRUN: u32 = 2;
pub const BLADERF_META_FLAG_TX_BURST_START: u32 = 1;
pub const BLADERF_META_FLAG_TX_BURST_END: u32 = 2;
pub const BLADERF_META_FLAG_TX_NOW: u32 = 4;
pub const BLADERF_META_FLAG_TX_UPDATE_TIMESTAMP: u32 = 8;
pub const BLADERF_META_FLAG_RX_NOW: u32 = 2147483648;
pub const BLADERF_META_FLAG_RX_HW_UNDERFLOW: u32 = 1;
pub const BLADERF_META_FLAG_RX_HW_MINIEXP1: u32 = 65536;
pub const BLADERF_META_FLAG_RX_HW_MINIEXP2: u32 = 131072;
pub const BLADERF_IMAGE_MAGIC_LEN: u32 = 7;
pub const BLADERF_IMAGE_CHECKSUM_LEN: u32 = 32;
pub const BLADERF_IMAGE_RESERVED_LEN: u32 = 128;
pub const BLADERF_ERR_UNEXPECTED: i32 = -1;
pub const BLADERF_ERR_RANGE: i32 = -2;
pub const BLADERF_ERR_INVAL: i32 = -3;
pub const BLADERF_ERR_MEM: i32 = -4;
pub const BLADERF_ERR_IO: i32 = -5;
pub const BLADERF_ERR_TIMEOUT: i32 = -6;
pub const BLADERF_ERR_NODEV: i32 = -7;
pub const BLADERF_ERR_UNSUPPORTED: i32 = -8;
pub const BLADERF_ERR_MISALIGNED: i32 = -9;
pub const BLADERF_ERR_CHECKSUM: i32 = -10;
pub const BLADERF_ERR_NO_FILE: i32 = -11;
pub const BLADERF_ERR_UPDATE_FPGA: i32 = -12;
pub const BLADERF_ERR_UPDATE_FW: i32 = -13;
pub const BLADERF_ERR_TIME_PAST: i32 = -14;
pub const BLADERF_ERR_QUEUE_FULL: i32 = -15;
pub const BLADERF_ERR_FPGA_OP: i32 = -16;
pub const BLADERF_ERR_PERMISSION: i32 = -17;
pub const BLADERF_ERR_WOULD_BLOCK: i32 = -18;
pub const BLADERF_ERR_NOT_INIT: i32 = -19;
pub const BLADERF_SAMPLERATE_MIN: u32 = 80000;
pub const BLADERF_SAMPLERATE_REC_MAX: u32 = 40000000;
pub const BLADERF_BANDWIDTH_MIN: u32 = 1500000;
pub const BLADERF_BANDWIDTH_MAX: u32 = 28000000;
pub const BLADERF_FREQUENCY_MIN_XB200: u32 = 0;
pub const BLADERF_FREQUENCY_MIN: u32 = 237500000;
pub const BLADERF_FREQUENCY_MAX: u32 = 3800000000;
pub const BLADERF_FLASH_ADDR_FIRMWARE: u32 = 0;
pub const BLADERF_FLASH_BYTE_LEN_FIRMWARE: u32 = 196608;
pub const BLADERF_FLASH_ADDR_CAL: u32 = 196608;
pub const BLADERF_FLASH_BYTE_LEN_CAL: u32 = 256;
pub const BLADERF_FLASH_ADDR_FPGA: u32 = 262144;
pub const BLADERF_RXVGA1_GAIN_MIN: u32 = 5;
pub const BLADERF_RXVGA1_GAIN_MAX: u32 = 30;
pub const BLADERF_RXVGA2_GAIN_MIN: u32 = 0;
pub const BLADERF_RXVGA2_GAIN_MAX: u32 = 30;
pub const BLADERF_TXVGA1_GAIN_MIN: i32 = -35;
pub const BLADERF_TXVGA1_GAIN_MAX: i32 = -4;
pub const BLADERF_TXVGA2_GAIN_MIN: u32 = 0;
pub const BLADERF_TXVGA2_GAIN_MAX: u32 = 25;
pub const BLADERF_LNA_GAIN_MID_DB: u32 = 3;
pub const BLADERF_LNA_GAIN_MAX_DB: u32 = 6;
pub const BLADERF_SMB_FREQUENCY_MAX: u32 = 200000000;
pub const BLADERF_SMB_FREQUENCY_MIN: u32 = 139682;
pub const BLADERF_GPIO_LMS_RX_ENABLE: u32 = 2;
pub const BLADERF_GPIO_LMS_TX_ENABLE: u32 = 4;
pub const BLADERF_GPIO_TX_LB_ENABLE: u32 = 16;
pub const BLADERF_GPIO_TX_HB_ENABLE: u32 = 8;
pub const BLADERF_GPIO_COUNTER_ENABLE: u32 = 512;
pub const BLADERF_GPIO_RX_MUX_SHIFT: u32 = 8;
pub const BLADERF_GPIO_RX_LB_ENABLE: u32 = 64;
pub const BLADERF_GPIO_RX_HB_ENABLE: u32 = 32;
pub const BLADERF_GPIO_FEATURE_SMALL_DMA_XFER: u32 = 128;
pub const BLADERF_GPIO_PACKET: u32 = 524288;
pub const BLADERF_GPIO_8BIT_MODE: u32 = 1048576;
pub const BLADERF_GPIO_AGC_ENABLE: u32 = 262144;
pub const BLADERF_GPIO_TIMESTAMP: u32 = 65536;
pub const BLADERF_GPIO_TIMESTAMP_DIV2: u32 = 131072;
pub const BLADERF_GPIO_PACKET_CORE_PRESENT: u32 = 268435456;
pub type __int8_t = ::libc::c_schar;
pub type __uint8_t = ::libc::c_uchar;
pub type __int16_t = ::libc::c_short;
pub type __uint16_t = ::libc::c_ushort;
pub type __int32_t = ::libc::c_int;
pub type __uint32_t = ::libc::c_uint;
pub type __int64_t = ::libc::c_longlong;
pub type __uint64_t = ::libc::c_ulonglong;
pub type __darwin_intptr_t = ::libc::c_long;
pub type __darwin_natural_t = ::libc::c_uint;
pub type __darwin_ct_rune_t = ::libc::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::libc::c_char; 128usize],
    pub _mbstateL: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::libc::c_long;
pub type __darwin_size_t = ::libc::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::libc::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::libc::c_int;
pub type __darwin_clock_t = ::libc::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::libc::c_long;
pub type __darwin_time_t = ::libc::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::libc::c_uint;
pub type __darwin_fsfilcnt_t = ::libc::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::libc::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::libc::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::libc::c_void)>,
    pub __arg: *mut ::libc::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::libc::c_long,
    pub __opaque: [::libc::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::libc::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::libc::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::libc::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type __darwin_nl_item = ::libc::c_int;
pub type __darwin_wctrans_t = ::libc::c_int;
pub type __darwin_wctype_t = __uint32_t;
pub type wchar_t = __darwin_wchar_t;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type u_int8_t = ::libc::c_uchar;
pub type u_int16_t = ::libc::c_ushort;
pub type u_int32_t = ::libc::c_uint;
pub type u_int64_t = ::libc::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::libc::c_long;
pub type uintmax_t = ::libc::c_ulong;
extern "C" {
    pub fn imaxabs(j: intmax_t) -> intmax_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct imaxdiv_t {
    pub quot: intmax_t,
    pub rem: intmax_t,
}
#[test]
fn bindgen_test_layout_imaxdiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<imaxdiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<imaxdiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<imaxdiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(imaxdiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(imaxdiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub fn imaxdiv(__numer: intmax_t, __denom: intmax_t) -> imaxdiv_t;
}
extern "C" {
    pub fn strtoimax(
        __nptr: *const ::libc::c_char,
        __endptr: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn strtoumax(
        __nptr: *const ::libc::c_char,
        __endptr: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> uintmax_t;
}
extern "C" {
    pub fn wcstoimax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::libc::c_int,
    ) -> intmax_t;
}
extern "C" {
    pub fn wcstoumax(
        __nptr: *const wchar_t,
        __endptr: *mut *mut wchar_t,
        __base: ::libc::c_int,
    ) -> uintmax_t;
}
pub const idtype_t_P_ALL: idtype_t = 0;
pub const idtype_t_P_PID: idtype_t = 1;
pub const idtype_t_P_PGID: idtype_t = 2;
pub type idtype_t = ::libc::c_uint;
pub type pid_t = __darwin_pid_t;
pub type id_t = __darwin_id_t;
pub type sig_atomic_t = ::libc::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state {
    pub __exception: __uint32_t,
    pub __fsr: __uint32_t,
    pub __far: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state>(),
        12usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__exception)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fsr) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__fsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state),
            "::",
            stringify!(__far)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_exception_state64 {
    pub __far: __uint64_t,
    pub __esr: __uint32_t,
    pub __exception: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_exception_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_exception_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_exception_state64>(),
        16usize,
        concat!("Size of: ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_exception_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_exception_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__far) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__far)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__esr) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__esr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__exception) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_exception_state64),
            "::",
            stringify!(__exception)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state {
    pub __r: [__uint32_t; 13usize],
    pub __sp: __uint32_t,
    pub __lr: __uint32_t,
    pub __pc: __uint32_t,
    pub __cpsr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state>(),
        68usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state),
            "::",
            stringify!(__cpsr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_thread_state64 {
    pub __x: [__uint64_t; 29usize],
    pub __fp: __uint64_t,
    pub __lr: __uint64_t,
    pub __sp: __uint64_t,
    pub __pc: __uint64_t,
    pub __cpsr: __uint32_t,
    pub __pad: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_thread_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_thread_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_thread_state64>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_thread_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_thread_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__x)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fp) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__fp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__lr) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__lr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sp) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pc) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pc)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cpsr) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__cpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_thread_state64),
            "::",
            stringify!(__pad)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_vfp_state {
    pub __r: [__uint32_t; 64usize],
    pub __fpscr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_vfp_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_vfp_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_vfp_state>(),
        260usize,
        concat!("Size of: ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_vfp_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_arm_vfp_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__r) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__r)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpscr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_vfp_state),
            "::",
            stringify!(__fpscr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state64 {
    pub __v: [__uint128_t; 32usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state64>(),
        528usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        516usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state64),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_neon_state {
    pub __v: [__uint128_t; 16usize],
    pub __fpsr: __uint32_t,
    pub __fpcr: __uint32_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_neon_state() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_neon_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_neon_state>(),
        272usize,
        concat!("Size of: ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_neon_state>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_arm_neon_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__v) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__v)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpsr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpsr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fpcr) as usize - ptr as usize },
        260usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_neon_state),
            "::",
            stringify!(__fpcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_pagein_state {
    pub __pagein_error: ::libc::c_int,
}
#[test]
fn bindgen_test_layout___arm_pagein_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_pagein_state> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_pagein_state>(),
        4usize,
        concat!("Size of: ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_pagein_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_pagein_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pagein_error) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_pagein_state),
            "::",
            stringify!(__pagein_error)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __arm_legacy_debug_state {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
}
#[test]
fn bindgen_test_layout___arm_legacy_debug_state() {
    const UNINIT: ::std::mem::MaybeUninit<__arm_legacy_debug_state> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__arm_legacy_debug_state>(),
        256usize,
        concat!("Size of: ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        ::std::mem::align_of::<__arm_legacy_debug_state>(),
        4usize,
        concat!("Alignment of ", stringify!(__arm_legacy_debug_state))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__arm_legacy_debug_state),
            "::",
            stringify!(__wcr)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state32 {
    pub __bvr: [__uint32_t; 16usize],
    pub __bcr: [__uint32_t; 16usize],
    pub __wvr: [__uint32_t; 16usize],
    pub __wcr: [__uint32_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state32> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state32>(),
        264usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state32>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state32),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_debug_state64 {
    pub __bvr: [__uint64_t; 16usize],
    pub __bcr: [__uint64_t; 16usize],
    pub __wvr: [__uint64_t; 16usize],
    pub __wcr: [__uint64_t; 16usize],
    pub __mdscr_el1: __uint64_t,
}
#[test]
fn bindgen_test_layout___darwin_arm_debug_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_debug_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_debug_state64>(),
        520usize,
        concat!("Size of: ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_debug_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_debug_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bvr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__bcr) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__bcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wvr) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wvr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__wcr) as usize - ptr as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__wcr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mdscr_el1) as usize - ptr as usize },
        512usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_debug_state64),
            "::",
            stringify!(__mdscr_el1)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_arm_cpmu_state64 {
    pub __ctrs: [__uint64_t; 16usize],
}
#[test]
fn bindgen_test_layout___darwin_arm_cpmu_state64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_arm_cpmu_state64> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_arm_cpmu_state64>(),
        128usize,
        concat!("Size of: ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_arm_cpmu_state64>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_arm_cpmu_state64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ctrs) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_arm_cpmu_state64),
            "::",
            stringify!(__ctrs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext32 {
    pub __es: __darwin_arm_exception_state,
    pub __ss: __darwin_arm_thread_state,
    pub __fs: __darwin_arm_vfp_state,
}
#[test]
fn bindgen_test_layout___darwin_mcontext32() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext32>(),
        340usize,
        concat!("Size of: ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext32>(),
        4usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__fs) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext32),
            "::",
            stringify!(__fs)
        )
    );
}
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_mcontext64 {
    pub __es: __darwin_arm_exception_state64,
    pub __ss: __darwin_arm_thread_state64,
    pub __ns: __darwin_arm_neon_state64,
}
#[test]
fn bindgen_test_layout___darwin_mcontext64() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_mcontext64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_mcontext64>(),
        816usize,
        concat!("Size of: ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_mcontext64>(),
        16usize,
        concat!("Alignment of ", stringify!(__darwin_mcontext64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__es) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__es)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ss) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__ns) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_mcontext64),
            "::",
            stringify!(__ns)
        )
    );
}
pub type mcontext_t = *mut __darwin_mcontext64;
pub type pthread_attr_t = __darwin_pthread_attr_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_sigaltstack {
    pub ss_sp: *mut ::libc::c_void,
    pub ss_size: __darwin_size_t,
    pub ss_flags: ::libc::c_int,
}
#[test]
fn bindgen_test_layout___darwin_sigaltstack() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_sigaltstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_sigaltstack>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_sigaltstack>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_sigaltstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_size) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_flags) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_sigaltstack),
            "::",
            stringify!(ss_flags)
        )
    );
}
pub type stack_t = __darwin_sigaltstack;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_ucontext {
    pub uc_onstack: ::libc::c_int,
    pub uc_sigmask: __darwin_sigset_t,
    pub uc_stack: __darwin_sigaltstack,
    pub uc_link: *mut __darwin_ucontext,
    pub uc_mcsize: __darwin_size_t,
    pub uc_mcontext: *mut __darwin_mcontext64,
}
#[test]
fn bindgen_test_layout___darwin_ucontext() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_ucontext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_ucontext>(),
        56usize,
        concat!("Size of: ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_ucontext>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_ucontext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_onstack) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_onstack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_sigmask) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_sigmask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_link) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_link)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcsize) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcsize)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).uc_mcontext) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_ucontext),
            "::",
            stringify!(uc_mcontext)
        )
    );
}
pub type ucontext_t = __darwin_ucontext;
pub type sigset_t = __darwin_sigset_t;
pub type uid_t = __darwin_uid_t;
#[repr(C)]
#[derive(Copy, Clone)]
pub union sigval {
    pub sival_int: ::libc::c_int,
    pub sival_ptr: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_sigval() {
    const UNINIT: ::std::mem::MaybeUninit<sigval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigval>(),
        8usize,
        concat!("Size of: ", stringify!(sigval))
    );
    assert_eq!(
        ::std::mem::align_of::<sigval>(),
        8usize,
        concat!("Alignment of ", stringify!(sigval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_int) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_int)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sival_ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigval),
            "::",
            stringify!(sival_ptr)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigevent {
    pub sigev_notify: ::libc::c_int,
    pub sigev_signo: ::libc::c_int,
    pub sigev_value: sigval,
    pub sigev_notify_function: ::std::option::Option<unsafe extern "C" fn(arg1: sigval)>,
    pub sigev_notify_attributes: *mut pthread_attr_t,
}
#[test]
fn bindgen_test_layout_sigevent() {
    const UNINIT: ::std::mem::MaybeUninit<sigevent> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigevent>(),
        32usize,
        concat!("Size of: ", stringify!(sigevent))
    );
    assert_eq!(
        ::std::mem::align_of::<sigevent>(),
        8usize,
        concat!("Alignment of ", stringify!(sigevent))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_signo) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_value) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_function) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_function)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sigev_notify_attributes) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sigevent),
            "::",
            stringify!(sigev_notify_attributes)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __siginfo {
    pub si_signo: ::libc::c_int,
    pub si_errno: ::libc::c_int,
    pub si_code: ::libc::c_int,
    pub si_pid: pid_t,
    pub si_uid: uid_t,
    pub si_status: ::libc::c_int,
    pub si_addr: *mut ::libc::c_void,
    pub si_value: sigval,
    pub si_band: ::libc::c_long,
    pub __pad: [::libc::c_ulong; 7usize],
}
#[test]
fn bindgen_test_layout___siginfo() {
    const UNINIT: ::std::mem::MaybeUninit<__siginfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__siginfo>(),
        104usize,
        concat!("Size of: ", stringify!(__siginfo))
    );
    assert_eq!(
        ::std::mem::align_of::<__siginfo>(),
        8usize,
        concat!("Alignment of ", stringify!(__siginfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_signo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_signo)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_errno) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_errno)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_code) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_code)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_pid) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_pid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_uid) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_uid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_status) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_addr) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_value) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_value)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).si_band) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(si_band)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__pad) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(__siginfo),
            "::",
            stringify!(__pad)
        )
    );
}
pub type siginfo_t = __siginfo;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __sigaction_u {
    pub __sa_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub __sa_sigaction: ::std::option::Option<
        unsafe extern "C" fn(arg1: ::libc::c_int, arg2: *mut __siginfo, arg3: *mut ::libc::c_void),
    >,
}
#[test]
fn bindgen_test_layout___sigaction_u() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction_u> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction_u>(),
        8usize,
        concat!("Size of: ", stringify!(__sigaction_u))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction_u>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction_u))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sa_sigaction) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction_u),
            "::",
            stringify!(__sa_sigaction)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_tramp: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut ::libc::c_void,
            arg2: ::libc::c_int,
            arg3: ::libc::c_int,
            arg4: *mut siginfo_t,
            arg5: *mut ::libc::c_void,
        ),
    >,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
#[test]
fn bindgen_test_layout___sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<__sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__sigaction>(),
        24usize,
        concat!("Size of: ", stringify!(__sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<__sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(__sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_tramp) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_tramp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sigaction {
    pub __sigaction_u: __sigaction_u,
    pub sa_mask: sigset_t,
    pub sa_flags: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_sigaction() {
    const UNINIT: ::std::mem::MaybeUninit<sigaction> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigaction>(),
        16usize,
        concat!("Size of: ", stringify!(sigaction))
    );
    assert_eq!(
        ::std::mem::align_of::<sigaction>(),
        8usize,
        concat!("Alignment of ", stringify!(sigaction))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sigaction_u) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(__sigaction_u)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sa_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigaction),
            "::",
            stringify!(sa_flags)
        )
    );
}
pub type sig_t = ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigvec {
    pub sv_handler: ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    pub sv_mask: ::libc::c_int,
    pub sv_flags: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_sigvec() {
    const UNINIT: ::std::mem::MaybeUninit<sigvec> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigvec>(),
        16usize,
        concat!("Size of: ", stringify!(sigvec))
    );
    assert_eq!(
        ::std::mem::align_of::<sigvec>(),
        8usize,
        concat!("Alignment of ", stringify!(sigvec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_handler) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_handler)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_mask) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_mask)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).sv_flags) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(sigvec),
            "::",
            stringify!(sv_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct sigstack {
    pub ss_sp: *mut ::libc::c_char,
    pub ss_onstack: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_sigstack() {
    const UNINIT: ::std::mem::MaybeUninit<sigstack> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<sigstack>(),
        16usize,
        concat!("Size of: ", stringify!(sigstack))
    );
    assert_eq!(
        ::std::mem::align_of::<sigstack>(),
        8usize,
        concat!("Alignment of ", stringify!(sigstack))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_sp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_sp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ss_onstack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sigstack),
            "::",
            stringify!(ss_onstack)
        )
    );
}
extern "C" {
    pub fn signal(
        arg1: ::libc::c_int,
        arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
    ) -> ::std::option::Option<
        unsafe extern "C" fn(
            arg1: ::libc::c_int,
            arg2: ::std::option::Option<unsafe extern "C" fn(arg1: ::libc::c_int)>,
        ),
    >;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: __darwin_time_t,
    pub tv_usec: __darwin_suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    const UNINIT: ::std::mem::MaybeUninit<timeval> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_sec) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tv_usec) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
pub type rlim_t = __uint64_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage {
    pub ru_utime: timeval,
    pub ru_stime: timeval,
    pub ru_maxrss: ::libc::c_long,
    pub ru_ixrss: ::libc::c_long,
    pub ru_idrss: ::libc::c_long,
    pub ru_isrss: ::libc::c_long,
    pub ru_minflt: ::libc::c_long,
    pub ru_majflt: ::libc::c_long,
    pub ru_nswap: ::libc::c_long,
    pub ru_inblock: ::libc::c_long,
    pub ru_oublock: ::libc::c_long,
    pub ru_msgsnd: ::libc::c_long,
    pub ru_msgrcv: ::libc::c_long,
    pub ru_nsignals: ::libc::c_long,
    pub ru_nvcsw: ::libc::c_long,
    pub ru_nivcsw: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_rusage() {
    const UNINIT: ::std::mem::MaybeUninit<rusage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage>(),
        144usize,
        concat!("Size of: ", stringify!(rusage))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_utime) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_utime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_stime) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_stime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_maxrss) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_maxrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_ixrss) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_ixrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_idrss) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_idrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_isrss) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_isrss)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_minflt) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_minflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_majflt) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_majflt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nswap) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nswap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_inblock) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_inblock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_oublock) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_oublock)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgsnd) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgsnd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_msgrcv) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_msgrcv)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nsignals) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nsignals)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nvcsw) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nvcsw)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ru_nivcsw) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage),
            "::",
            stringify!(ru_nivcsw)
        )
    );
}
pub type rusage_info_t = *mut ::libc::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v0 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v0() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v0> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v0>(),
        96usize,
        concat!("Size of: ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v0>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v0))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v0),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v1 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v1() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v1> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v1>(),
        144usize,
        concat!("Size of: ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v1>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v1))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v1),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v2 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v2() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v2> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v2>(),
        160usize,
        concat!("Size of: ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v2>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v2))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v2),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v3 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v3() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v3> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v3>(),
        232usize,
        concat!("Size of: ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v3>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v3))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v3),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v4 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v4() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v4> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v4>(),
        296usize,
        concat!("Size of: ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v4>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v4))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v4),
            "::",
            stringify!(ri_runnable_time)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v5 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
}
#[test]
fn bindgen_test_layout_rusage_info_v5() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v5> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v5>(),
        304usize,
        concat!("Size of: ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v5>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v5))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v5),
            "::",
            stringify!(ri_flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rusage_info_v6 {
    pub ri_uuid: [u8; 16usize],
    pub ri_user_time: u64,
    pub ri_system_time: u64,
    pub ri_pkg_idle_wkups: u64,
    pub ri_interrupt_wkups: u64,
    pub ri_pageins: u64,
    pub ri_wired_size: u64,
    pub ri_resident_size: u64,
    pub ri_phys_footprint: u64,
    pub ri_proc_start_abstime: u64,
    pub ri_proc_exit_abstime: u64,
    pub ri_child_user_time: u64,
    pub ri_child_system_time: u64,
    pub ri_child_pkg_idle_wkups: u64,
    pub ri_child_interrupt_wkups: u64,
    pub ri_child_pageins: u64,
    pub ri_child_elapsed_abstime: u64,
    pub ri_diskio_bytesread: u64,
    pub ri_diskio_byteswritten: u64,
    pub ri_cpu_time_qos_default: u64,
    pub ri_cpu_time_qos_maintenance: u64,
    pub ri_cpu_time_qos_background: u64,
    pub ri_cpu_time_qos_utility: u64,
    pub ri_cpu_time_qos_legacy: u64,
    pub ri_cpu_time_qos_user_initiated: u64,
    pub ri_cpu_time_qos_user_interactive: u64,
    pub ri_billed_system_time: u64,
    pub ri_serviced_system_time: u64,
    pub ri_logical_writes: u64,
    pub ri_lifetime_max_phys_footprint: u64,
    pub ri_instructions: u64,
    pub ri_cycles: u64,
    pub ri_billed_energy: u64,
    pub ri_serviced_energy: u64,
    pub ri_interval_max_phys_footprint: u64,
    pub ri_runnable_time: u64,
    pub ri_flags: u64,
    pub ri_user_ptime: u64,
    pub ri_system_ptime: u64,
    pub ri_pinstructions: u64,
    pub ri_pcycles: u64,
    pub ri_energy_nj: u64,
    pub ri_penergy_nj: u64,
    pub ri_reserved: [u64; 14usize],
}
#[test]
fn bindgen_test_layout_rusage_info_v6() {
    const UNINIT: ::std::mem::MaybeUninit<rusage_info_v6> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rusage_info_v6>(),
        464usize,
        concat!("Size of: ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        ::std::mem::align_of::<rusage_info_v6>(),
        8usize,
        concat!("Alignment of ", stringify!(rusage_info_v6))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_uuid) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_uuid)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_time) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_time) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pkg_idle_wkups) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_interrupt_wkups) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pageins) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_wired_size) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_wired_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_resident_size) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_resident_size)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_phys_footprint) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_start_abstime) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_start_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_proc_exit_abstime) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_proc_exit_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_user_time) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_user_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_system_time) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pkg_idle_wkups) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pkg_idle_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_interrupt_wkups) as usize - ptr as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_interrupt_wkups)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_pageins) as usize - ptr as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_pageins)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_child_elapsed_abstime) as usize - ptr as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_child_elapsed_abstime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_bytesread) as usize - ptr as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_bytesread)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_diskio_byteswritten) as usize - ptr as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_diskio_byteswritten)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_default) as usize - ptr as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_default)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_maintenance) as usize - ptr as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_maintenance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_background) as usize - ptr as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_background)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_utility) as usize - ptr as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_utility)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_legacy) as usize - ptr as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_legacy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_initiated) as usize - ptr as usize
        },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_initiated)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_cpu_time_qos_user_interactive) as usize - ptr as usize
        },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cpu_time_qos_user_interactive)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_system_time) as usize - ptr as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_system_time) as usize - ptr as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_system_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_logical_writes) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_logical_writes)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_lifetime_max_phys_footprint) as usize - ptr as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_lifetime_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_instructions) as usize - ptr as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_instructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_cycles) as usize - ptr as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_cycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_billed_energy) as usize - ptr as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_billed_energy)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_serviced_energy) as usize - ptr as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_serviced_energy)
        )
    );
    assert_eq!(
        unsafe {
            ::std::ptr::addr_of!((*ptr).ri_interval_max_phys_footprint) as usize - ptr as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_interval_max_phys_footprint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_runnable_time) as usize - ptr as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_runnable_time)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_flags) as usize - ptr as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_user_ptime) as usize - ptr as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_user_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_system_ptime) as usize - ptr as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_system_ptime)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pinstructions) as usize - ptr as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pinstructions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_pcycles) as usize - ptr as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_pcycles)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_energy_nj) as usize - ptr as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_energy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_penergy_nj) as usize - ptr as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_penergy_nj)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ri_reserved) as usize - ptr as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rusage_info_v6),
            "::",
            stringify!(ri_reserved)
        )
    );
}
pub type rusage_info_current = rusage_info_v6;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rlimit {
    pub rlim_cur: rlim_t,
    pub rlim_max: rlim_t,
}
#[test]
fn bindgen_test_layout_rlimit() {
    const UNINIT: ::std::mem::MaybeUninit<rlimit> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<rlimit>(),
        16usize,
        concat!("Size of: ", stringify!(rlimit))
    );
    assert_eq!(
        ::std::mem::align_of::<rlimit>(),
        8usize,
        concat!("Alignment of ", stringify!(rlimit))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_cur) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_cur)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rlim_max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rlimit),
            "::",
            stringify!(rlim_max)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct proc_rlimit_control_wakeupmon {
    pub wm_flags: u32,
    pub wm_rate: i32,
}
#[test]
fn bindgen_test_layout_proc_rlimit_control_wakeupmon() {
    const UNINIT: ::std::mem::MaybeUninit<proc_rlimit_control_wakeupmon> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<proc_rlimit_control_wakeupmon>(),
        8usize,
        concat!("Size of: ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        ::std::mem::align_of::<proc_rlimit_control_wakeupmon>(),
        4usize,
        concat!("Alignment of ", stringify!(proc_rlimit_control_wakeupmon))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_flags) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).wm_rate) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(proc_rlimit_control_wakeupmon),
            "::",
            stringify!(wm_rate)
        )
    );
}
extern "C" {
    pub fn getpriority(arg1: ::libc::c_int, arg2: id_t) -> ::libc::c_int;
}
extern "C" {
    pub fn getiopolicy_np(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn getrlimit(arg1: ::libc::c_int, arg2: *mut rlimit) -> ::libc::c_int;
}
extern "C" {
    pub fn getrusage(arg1: ::libc::c_int, arg2: *mut rusage) -> ::libc::c_int;
}
extern "C" {
    pub fn setpriority(arg1: ::libc::c_int, arg2: id_t, arg3: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn setiopolicy_np(
        arg1: ::libc::c_int,
        arg2: ::libc::c_int,
        arg3: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn setrlimit(arg1: ::libc::c_int, arg2: *const rlimit) -> ::libc::c_int;
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU16 {
    pub __val: u16,
}
#[test]
fn bindgen_test_layout__OSUnalignedU16() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU16>(),
        2usize,
        concat!("Size of: ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU16>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU16),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU32 {
    pub __val: u32,
}
#[test]
fn bindgen_test_layout__OSUnalignedU32() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU32> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU32>(),
        4usize,
        concat!("Size of: ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU32>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU32))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU32),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct _OSUnalignedU64 {
    pub __val: u64,
}
#[test]
fn bindgen_test_layout__OSUnalignedU64() {
    const UNINIT: ::std::mem::MaybeUninit<_OSUnalignedU64> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_OSUnalignedU64>(),
        8usize,
        concat!("Size of: ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        ::std::mem::align_of::<_OSUnalignedU64>(),
        1usize,
        concat!("Alignment of ", stringify!(_OSUnalignedU64))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_OSUnalignedU64),
            "::",
            stringify!(__val)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union wait {
    pub w_status: ::libc::c_int,
    pub w_T: wait__bindgen_ty_1,
    pub w_S: wait__bindgen_ty_2,
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_1 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_1))
    );
}
impl wait__bindgen_ty_1 {
    #[inline]
    pub fn w_Termsig(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 7u8) as u32) }
    }
    #[inline]
    pub fn set_w_Termsig(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 7u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Coredump(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(7usize, 1u8) as u32) }
    }
    #[inline]
    pub fn set_w_Coredump(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(7usize, 1u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Retcode(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Retcode(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Termsig: ::libc::c_uint,
        w_Coredump: ::libc::c_uint,
        w_Retcode: ::libc::c_uint,
        w_Filler: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 7u8, {
            let w_Termsig: u32 = unsafe { ::std::mem::transmute(w_Termsig) };
            w_Termsig as u64
        });
        __bindgen_bitfield_unit.set(7usize, 1u8, {
            let w_Coredump: u32 = unsafe { ::std::mem::transmute(w_Coredump) };
            w_Coredump as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Retcode: u32 = unsafe { ::std::mem::transmute(w_Retcode) };
            w_Retcode as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[repr(C)]
#[repr(align(4))]
#[derive(Debug, Copy, Clone)]
pub struct wait__bindgen_ty_2 {
    pub _bitfield_align_1: [u16; 0],
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 4usize]>,
}
#[test]
fn bindgen_test_layout_wait__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Size of: ", stringify!(wait__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<wait__bindgen_ty_2>(),
        4usize,
        concat!("Alignment of ", stringify!(wait__bindgen_ty_2))
    );
}
impl wait__bindgen_ty_2 {
    #[inline]
    pub fn w_Stopval(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(0usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopval(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(0usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Stopsig(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(8usize, 8u8) as u32) }
    }
    #[inline]
    pub fn set_w_Stopsig(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(8usize, 8u8, val as u64)
        }
    }
    #[inline]
    pub fn w_Filler(&self) -> ::libc::c_uint {
        unsafe { ::std::mem::transmute(self._bitfield_1.get(16usize, 16u8) as u32) }
    }
    #[inline]
    pub fn set_w_Filler(&mut self, val: ::libc::c_uint) {
        unsafe {
            let val: u32 = ::std::mem::transmute(val);
            self._bitfield_1.set(16usize, 16u8, val as u64)
        }
    }
    #[inline]
    pub fn new_bitfield_1(
        w_Stopval: ::libc::c_uint,
        w_Stopsig: ::libc::c_uint,
        w_Filler: ::libc::c_uint,
    ) -> __BindgenBitfieldUnit<[u8; 4usize]> {
        let mut __bindgen_bitfield_unit: __BindgenBitfieldUnit<[u8; 4usize]> = Default::default();
        __bindgen_bitfield_unit.set(0usize, 8u8, {
            let w_Stopval: u32 = unsafe { ::std::mem::transmute(w_Stopval) };
            w_Stopval as u64
        });
        __bindgen_bitfield_unit.set(8usize, 8u8, {
            let w_Stopsig: u32 = unsafe { ::std::mem::transmute(w_Stopsig) };
            w_Stopsig as u64
        });
        __bindgen_bitfield_unit.set(16usize, 16u8, {
            let w_Filler: u32 = unsafe { ::std::mem::transmute(w_Filler) };
            w_Filler as u64
        });
        __bindgen_bitfield_unit
    }
}
#[test]
fn bindgen_test_layout_wait() {
    const UNINIT: ::std::mem::MaybeUninit<wait> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<wait>(),
        4usize,
        concat!("Size of: ", stringify!(wait))
    );
    assert_eq!(
        ::std::mem::align_of::<wait>(),
        4usize,
        concat!("Alignment of ", stringify!(wait))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_status) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(wait),
            "::",
            stringify!(w_status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_T) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_T))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).w_S) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(wait), "::", stringify!(w_S))
    );
}
extern "C" {
    pub fn wait(arg1: *mut ::libc::c_int) -> pid_t;
}
extern "C" {
    pub fn waitpid(arg1: pid_t, arg2: *mut ::libc::c_int, arg3: ::libc::c_int) -> pid_t;
}
extern "C" {
    pub fn waitid(
        arg1: idtype_t,
        arg2: id_t,
        arg3: *mut siginfo_t,
        arg4: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn wait3(arg1: *mut ::libc::c_int, arg2: ::libc::c_int, arg3: *mut rusage) -> pid_t;
}
extern "C" {
    pub fn wait4(
        arg1: pid_t,
        arg2: *mut ::libc::c_int,
        arg3: ::libc::c_int,
        arg4: *mut rusage,
    ) -> pid_t;
}
extern "C" {
    pub fn alloca(arg1: ::libc::c_ulong) -> *mut ::libc::c_void;
}
pub type ct_rune_t = __darwin_ct_rune_t;
pub type rune_t = __darwin_rune_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct div_t {
    pub quot: ::libc::c_int,
    pub rem: ::libc::c_int,
}
#[test]
fn bindgen_test_layout_div_t() {
    const UNINIT: ::std::mem::MaybeUninit<div_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<div_t>(),
        8usize,
        concat!("Size of: ", stringify!(div_t))
    );
    assert_eq!(
        ::std::mem::align_of::<div_t>(),
        4usize,
        concat!("Alignment of ", stringify!(div_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(div_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ldiv_t {
    pub quot: ::libc::c_long,
    pub rem: ::libc::c_long,
}
#[test]
fn bindgen_test_layout_ldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<ldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<ldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(ldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<ldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(ldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct lldiv_t {
    pub quot: ::libc::c_longlong,
    pub rem: ::libc::c_longlong,
}
#[test]
fn bindgen_test_layout_lldiv_t() {
    const UNINIT: ::std::mem::MaybeUninit<lldiv_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<lldiv_t>(),
        16usize,
        concat!("Size of: ", stringify!(lldiv_t))
    );
    assert_eq!(
        ::std::mem::align_of::<lldiv_t>(),
        8usize,
        concat!("Alignment of ", stringify!(lldiv_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).quot) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(quot)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rem) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(lldiv_t),
            "::",
            stringify!(rem)
        )
    );
}
extern "C" {
    pub static mut __mb_cur_max: ::libc::c_int;
}
pub type malloc_type_id_t = ::libc::c_ulonglong;
extern "C" {
    pub fn malloc_type_malloc(size: usize, type_id: malloc_type_id_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn malloc_type_calloc(
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn malloc_type_free(ptr: *mut ::libc::c_void, type_id: malloc_type_id_t);
}
extern "C" {
    pub fn malloc_type_realloc(
        ptr: *mut ::libc::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn malloc_type_valloc(size: usize, type_id: malloc_type_id_t) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn malloc_type_aligned_alloc(
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn malloc_type_posix_memalign(
        memptr: *mut *mut ::libc::c_void,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> ::libc::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _malloc_zone_t {
    _unused: [u8; 0],
}
pub type malloc_zone_t = _malloc_zone_t;
extern "C" {
    pub fn malloc_type_zone_malloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn malloc_type_zone_calloc(
        zone: *mut malloc_zone_t,
        count: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn malloc_type_zone_free(
        zone: *mut malloc_zone_t,
        ptr: *mut ::libc::c_void,
        type_id: malloc_type_id_t,
    );
}
extern "C" {
    pub fn malloc_type_zone_realloc(
        zone: *mut malloc_zone_t,
        ptr: *mut ::libc::c_void,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn malloc_type_zone_valloc(
        zone: *mut malloc_zone_t,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn malloc_type_zone_memalign(
        zone: *mut malloc_zone_t,
        alignment: usize,
        size: usize,
        type_id: malloc_type_id_t,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn malloc(__size: ::libc::c_ulong) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn calloc(__count: ::libc::c_ulong, __size: ::libc::c_ulong) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn free(arg1: *mut ::libc::c_void);
}
extern "C" {
    pub fn realloc(__ptr: *mut ::libc::c_void, __size: ::libc::c_ulong) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn valloc(arg1: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn aligned_alloc(
        __alignment: ::libc::c_ulong,
        __size: ::libc::c_ulong,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn posix_memalign(
        __memptr: *mut *mut ::libc::c_void,
        __alignment: usize,
        __size: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn abort() -> !;
}
extern "C" {
    pub fn abs(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn atexit(arg1: ::std::option::Option<unsafe extern "C" fn()>) -> ::libc::c_int;
}
extern "C" {
    pub fn atof(arg1: *const ::libc::c_char) -> f64;
}
extern "C" {
    pub fn atoi(arg1: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn atol(arg1: *const ::libc::c_char) -> ::libc::c_long;
}
extern "C" {
    pub fn atoll(arg1: *const ::libc::c_char) -> ::libc::c_longlong;
}
extern "C" {
    pub fn bsearch(
        __key: *const ::libc::c_void,
        __base: *const ::libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::libc::c_void,
                arg2: *const ::libc::c_void,
            ) -> ::libc::c_int,
        >,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn div(arg1: ::libc::c_int, arg2: ::libc::c_int) -> div_t;
}
extern "C" {
    pub fn exit(arg1: ::libc::c_int) -> !;
}
extern "C" {
    pub fn getenv(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn labs(arg1: ::libc::c_long) -> ::libc::c_long;
}
extern "C" {
    pub fn ldiv(arg1: ::libc::c_long, arg2: ::libc::c_long) -> ldiv_t;
}
extern "C" {
    pub fn llabs(arg1: ::libc::c_longlong) -> ::libc::c_longlong;
}
extern "C" {
    pub fn lldiv(arg1: ::libc::c_longlong, arg2: ::libc::c_longlong) -> lldiv_t;
}
extern "C" {
    pub fn mblen(__s: *const ::libc::c_char, __n: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn mbstowcs(arg1: *mut wchar_t, arg2: *const ::libc::c_char, arg3: usize) -> usize;
}
extern "C" {
    pub fn mbtowc(arg1: *mut wchar_t, arg2: *const ::libc::c_char, arg3: usize) -> ::libc::c_int;
}
extern "C" {
    pub fn qsort(
        __base: *mut ::libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::libc::c_void,
                arg2: *const ::libc::c_void,
            ) -> ::libc::c_int,
        >,
    );
}
extern "C" {
    pub fn rand() -> ::libc::c_int;
}
extern "C" {
    pub fn srand(arg1: ::libc::c_uint);
}
extern "C" {
    pub fn strtod(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char) -> f64;
}
extern "C" {
    pub fn strtof(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char) -> f32;
}
extern "C" {
    pub fn strtol(
        __str: *const ::libc::c_char,
        __endptr: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_long;
}
extern "C" {
    pub fn strtold(arg1: *const ::libc::c_char, arg2: *mut *mut ::libc::c_char) -> f64;
}
extern "C" {
    pub fn strtoll(
        __str: *const ::libc::c_char,
        __endptr: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_longlong;
}
extern "C" {
    pub fn strtoul(
        __str: *const ::libc::c_char,
        __endptr: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_ulong;
}
extern "C" {
    pub fn strtoull(
        __str: *const ::libc::c_char,
        __endptr: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_ulonglong;
}
extern "C" {
    pub fn system(arg1: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn wcstombs(arg1: *mut ::libc::c_char, arg2: *const wchar_t, arg3: usize) -> usize;
}
extern "C" {
    pub fn wctomb(arg1: *mut ::libc::c_char, arg2: wchar_t) -> ::libc::c_int;
}
extern "C" {
    pub fn _Exit(arg1: ::libc::c_int) -> !;
}
extern "C" {
    pub fn a64l(arg1: *const ::libc::c_char) -> ::libc::c_long;
}
extern "C" {
    pub fn drand48() -> f64;
}
extern "C" {
    pub fn ecvt(
        arg1: f64,
        arg2: ::libc::c_int,
        arg3: *mut ::libc::c_int,
        arg4: *mut ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn erand48(arg1: *mut ::libc::c_ushort) -> f64;
}
extern "C" {
    pub fn fcvt(
        arg1: f64,
        arg2: ::libc::c_int,
        arg3: *mut ::libc::c_int,
        arg4: *mut ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn gcvt(arg1: f64, arg2: ::libc::c_int, arg3: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn getsubopt(
        arg1: *mut *mut ::libc::c_char,
        arg2: *const *mut ::libc::c_char,
        arg3: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn grantpt(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn initstate(
        arg1: ::libc::c_uint,
        arg2: *mut ::libc::c_char,
        arg3: usize,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn jrand48(arg1: *mut ::libc::c_ushort) -> ::libc::c_long;
}
extern "C" {
    pub fn l64a(arg1: ::libc::c_long) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn lcong48(arg1: *mut ::libc::c_ushort);
}
extern "C" {
    pub fn lrand48() -> ::libc::c_long;
}
extern "C" {
    pub fn mktemp(arg1: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn mkstemp(arg1: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn mrand48() -> ::libc::c_long;
}
extern "C" {
    pub fn nrand48(arg1: *mut ::libc::c_ushort) -> ::libc::c_long;
}
extern "C" {
    pub fn posix_openpt(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn ptsname(arg1: ::libc::c_int) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn ptsname_r(
        fildes: ::libc::c_int,
        buffer: *mut ::libc::c_char,
        buflen: usize,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn putenv(arg1: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn random() -> ::libc::c_long;
}
extern "C" {
    pub fn rand_r(arg1: *mut ::libc::c_uint) -> ::libc::c_int;
}
extern "C" {
    #[link_name = "\u{1}_realpath$DARWIN_EXTSN"]
    pub fn realpath(arg1: *const ::libc::c_char, arg2: *mut ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn seed48(arg1: *mut ::libc::c_ushort) -> *mut ::libc::c_ushort;
}
extern "C" {
    pub fn setenv(
        __name: *const ::libc::c_char,
        __value: *const ::libc::c_char,
        __overwrite: ::libc::c_int,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn setkey(arg1: *const ::libc::c_char);
}
extern "C" {
    pub fn setstate(arg1: *const ::libc::c_char) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn srand48(arg1: ::libc::c_long);
}
extern "C" {
    pub fn srandom(arg1: ::libc::c_uint);
}
extern "C" {
    pub fn unlockpt(arg1: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn unsetenv(arg1: *const ::libc::c_char) -> ::libc::c_int;
}
pub type dev_t = __darwin_dev_t;
pub type mode_t = __darwin_mode_t;
extern "C" {
    pub fn arc4random() -> u32;
}
extern "C" {
    pub fn arc4random_addrandom(arg1: *mut ::libc::c_uchar, arg2: ::libc::c_int);
}
extern "C" {
    pub fn arc4random_buf(__buf: *mut ::libc::c_void, __nbytes: usize);
}
extern "C" {
    pub fn arc4random_stir();
}
extern "C" {
    pub fn arc4random_uniform(__upper_bound: u32) -> u32;
}
extern "C" {
    pub fn atexit_b(arg1: *mut ::libc::c_void) -> ::libc::c_int;
}
extern "C" {
    pub fn bsearch_b(
        __key: *const ::libc::c_void,
        __base: *const ::libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::libc::c_void,
    ) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn cgetcap(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn cgetclose() -> ::libc::c_int;
}
extern "C" {
    pub fn cgetent(
        arg1: *mut *mut ::libc::c_char,
        arg2: *mut *mut ::libc::c_char,
        arg3: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn cgetfirst(
        arg1: *mut *mut ::libc::c_char,
        arg2: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn cgetmatch(arg1: *const ::libc::c_char, arg2: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn cgetnext(
        arg1: *mut *mut ::libc::c_char,
        arg2: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn cgetnum(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: *mut ::libc::c_long,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn cgetset(arg1: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn cgetstr(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn cgetustr(
        arg1: *mut ::libc::c_char,
        arg2: *const ::libc::c_char,
        arg3: *mut *mut ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn daemon(arg1: ::libc::c_int, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn devname(arg1: dev_t, arg2: mode_t) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn devname_r(
        arg1: dev_t,
        arg2: mode_t,
        buf: *mut ::libc::c_char,
        len: ::libc::c_int,
    ) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn getbsize(arg1: *mut ::libc::c_int, arg2: *mut ::libc::c_long) -> *mut ::libc::c_char;
}
extern "C" {
    pub fn getloadavg(arg1: *mut f64, arg2: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    pub fn getprogname() -> *const ::libc::c_char;
}
extern "C" {
    pub fn setprogname(arg1: *const ::libc::c_char);
}
extern "C" {
    pub fn heapsort(
        __base: *mut ::libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::libc::c_void,
                arg2: *const ::libc::c_void,
            ) -> ::libc::c_int,
        >,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn heapsort_b(
        __base: *mut ::libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn mergesort(
        __base: *mut ::libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::libc::c_void,
                arg2: *const ::libc::c_void,
            ) -> ::libc::c_int,
        >,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn mergesort_b(
        __base: *mut ::libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn psort(
        __base: *mut ::libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *const ::libc::c_void,
                arg2: *const ::libc::c_void,
            ) -> ::libc::c_int,
        >,
    );
}
extern "C" {
    pub fn psort_b(
        __base: *mut ::libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn psort_r(
        __base: *mut ::libc::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::libc::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *const ::libc::c_void,
                arg3: *const ::libc::c_void,
            ) -> ::libc::c_int,
        >,
    );
}
extern "C" {
    pub fn qsort_b(
        __base: *mut ::libc::c_void,
        __nel: usize,
        __width: usize,
        __compar: *mut ::libc::c_void,
    );
}
extern "C" {
    pub fn qsort_r(
        __base: *mut ::libc::c_void,
        __nel: usize,
        __width: usize,
        arg1: *mut ::libc::c_void,
        __compar: ::std::option::Option<
            unsafe extern "C" fn(
                arg1: *mut ::libc::c_void,
                arg2: *const ::libc::c_void,
                arg3: *const ::libc::c_void,
            ) -> ::libc::c_int,
        >,
    );
}
extern "C" {
    pub fn radixsort(
        __base: *mut *const ::libc::c_uchar,
        __nel: ::libc::c_int,
        __table: *const ::libc::c_uchar,
        __endbyte: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn rpmatch(arg1: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    pub fn sradixsort(
        __base: *mut *const ::libc::c_uchar,
        __nel: ::libc::c_int,
        __table: *const ::libc::c_uchar,
        __endbyte: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    pub fn sranddev();
}
extern "C" {
    pub fn srandomdev();
}
extern "C" {
    pub fn reallocf(__ptr: *mut ::libc::c_void, __size: usize) -> *mut ::libc::c_void;
}
extern "C" {
    pub fn strtonum(
        __numstr: *const ::libc::c_char,
        __minval: ::libc::c_longlong,
        __maxval: ::libc::c_longlong,
        __errstrp: *mut *const ::libc::c_char,
    ) -> ::libc::c_longlong;
}
extern "C" {
    pub fn strtoq(
        __str: *const ::libc::c_char,
        __endptr: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_longlong;
}
extern "C" {
    pub fn strtouq(
        __str: *const ::libc::c_char,
        __endptr: *mut *mut ::libc::c_char,
        __base: ::libc::c_int,
    ) -> ::libc::c_ulonglong;
}
extern "C" {
    pub static mut suboptarg: *mut ::libc::c_char;
}
#[doc = " This structure is an opaque device handle"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf {
    _unused: [u8; 0],
}
#[doc = "< \"Don't Care\" -- use any available\n   backend"]
pub const bladerf_backend_BLADERF_BACKEND_ANY: bladerf_backend = 0;
#[doc = "< Linux kernel driver"]
pub const bladerf_backend_BLADERF_BACKEND_LINUX: bladerf_backend = 1;
#[doc = "< libusb"]
pub const bladerf_backend_BLADERF_BACKEND_LIBUSB: bladerf_backend = 2;
#[doc = "< CyAPI"]
pub const bladerf_backend_BLADERF_BACKEND_CYPRESS: bladerf_backend = 3;
#[doc = "< Dummy used for development purposes"]
pub const bladerf_backend_BLADERF_BACKEND_DUMMY: bladerf_backend = 100;
#[doc = " Backend by which the host communicates with the device"]
pub type bladerf_backend = ::libc::c_uint;
#[doc = " Information about a bladeRF attached to the system"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_devinfo {
    #[doc = "< Backend to use when connecting to\n   device"]
    pub backend: bladerf_backend,
    #[doc = "< Device serial number string"]
    pub serial: [::libc::c_char; 33usize],
    #[doc = "< Bus # device is attached to"]
    pub usb_bus: u8,
    #[doc = "< Device address on bus"]
    pub usb_addr: u8,
    #[doc = "< Device instance or ID"]
    pub instance: ::libc::c_uint,
    #[doc = " Manufacturer description string"]
    pub manufacturer: [::libc::c_char; 33usize],
    #[doc = "< Product description string"]
    pub product: [::libc::c_char; 33usize],
}
#[test]
fn bindgen_test_layout_bladerf_devinfo() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_devinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_devinfo>(),
        112usize,
        concat!("Size of: ", stringify!(bladerf_devinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_devinfo>(),
        4usize,
        concat!("Alignment of ", stringify!(bladerf_devinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).backend) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_devinfo),
            "::",
            stringify!(backend)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_devinfo),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usb_bus) as usize - ptr as usize },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_devinfo),
            "::",
            stringify!(usb_bus)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).usb_addr) as usize - ptr as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_devinfo),
            "::",
            stringify!(usb_addr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).instance) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_devinfo),
            "::",
            stringify!(instance)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).manufacturer) as usize - ptr as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_devinfo),
            "::",
            stringify!(manufacturer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).product) as usize - ptr as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_devinfo),
            "::",
            stringify!(product)
        )
    );
}
#[doc = " Information about a bladeRF attached to the system"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_backendinfo {
    #[doc = "< Backend handle count"]
    pub handle_count: ::libc::c_int,
    #[doc = "< Backend handle for device"]
    pub handle: *mut ::libc::c_void,
    #[doc = "< Backend lock count"]
    pub lock_count: ::libc::c_int,
    #[doc = "< Backend lock for device"]
    pub lock: *mut ::libc::c_void,
}
#[test]
fn bindgen_test_layout_bladerf_backendinfo() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_backendinfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_backendinfo>(),
        32usize,
        concat!("Size of: ", stringify!(bladerf_backendinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_backendinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(bladerf_backendinfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle_count) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_backendinfo),
            "::",
            stringify!(handle_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).handle) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_backendinfo),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_backendinfo),
            "::",
            stringify!(lock_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lock) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_backendinfo),
            "::",
            stringify!(lock)
        )
    );
}
extern "C" {
    #[doc = " Open specified device using a device identifier string. See\n bladerf_open_with_devinfo() if a device identifier string is not readily\n available.\n\n The general form of the device identifier string is;\n @code{.txt}\n      <backend>:[device=<bus>:<addr>] [instance=<n>] [serial=<serial>]\n @endcode\n\n An empty (\"\") or NULL device identifier will result in the first\n encountered device being opened (using the first discovered backend)\n\n The 'backend' describes the mechanism used to communicate with the device,\n and may be one of the following:\n   - *:       Any available backend\n   - libusb:  libusb (See libusb changelog notes for required version, given\n   your OS and controller)\n   - cypress: Cypress CyUSB/CyAPI backend (Windows only)\n\n If no arguments are provided after the backend, the first encountered\n device on the specified backend will be opened. Note that a backend is\n required, if any arguments are to be provided.\n\n Next, any provided arguments are provide as used to find the desired device.\n Be sure not to over constrain the search. Generally, only one of the above\n is required -- providing all of these may over constrain the search for the\n desired device (e.g., if a serial number matches, but not on the specified\n bus and address.)\n\n   - device=\\<bus\\>:\\<addr\\>\n      - Specifies USB bus and address. Decimal or hex prefixed by '0x' is\n        permitted.\n   - instance=\\<n\\>\n      - Nth instance encountered, 0-indexed\n   - serial=\\<serial\\>\n      - Device's serial number.\n\n Below is an example of how to open a device with a specific serial\n number, using any avaiable backend supported by libbladeRF:\n\n @code {.c}\n struct bladerf *dev;\n int status = bladerf_open(&dev, \"*:serial=f12ce1037830a1b27f3ceeba1f521413\");\n if (status != 0) {\n      fprintf(stderr, \"Unable to open device: %s\\n\",\n              bladerf_strerror(status));\n      return status;\n }\n @endcode\n\n @param[out]  device             Update with device handle on success\n @param[in]   device_identifier  Device identifier, formatted as described\n                                 above\n\n @return 0 on success, or value from \\ref RETCODES list on failure"]
    pub fn bladerf_open(
        device: *mut *mut bladerf,
        device_identifier: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Close device\n\n @note Failing to close a device will result in memory leaks.\n\n @post `device` is deallocated and may no longer be used.\n\n @param   device  Device handle previously obtained by bladerf_open(). This\n                  function does nothing if device is NULL."]
    pub fn bladerf_close(device: *mut bladerf);
}
extern "C" {
    #[doc = " Opens device specified by provided bladerf_devinfo structure\n\n This function is generally preferred over bladerf_open() when a device\n identifier string is not already provided.\n\n The most common uses of this function are to:\n  - Open a device based upon the results of bladerf_get_device_list()\n  - Open a specific device based upon its serial number\n\n Below is an example of how to use this function to open a device with a\n specific serial number:\n\n @snippet open_via_serial.c example_snippet\n\n @param[out]  device      Update with device handle on success\n @param[in]   devinfo     Device specification. If NULL, any available\n                          device will be opened.\n\n @return 0 on success, or value from \\ref RETCODES list on failure"]
    pub fn bladerf_open_with_devinfo(
        device: *mut *mut bladerf,
        devinfo: *mut bladerf_devinfo,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Obtain a list of bladeRF devices attached to the system\n\n @param[out]  devices\n\n @return number of items in returned device list, or value from\n         \\ref RETCODES list on failure"]
    pub fn bladerf_get_device_list(devices: *mut *mut bladerf_devinfo) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Free device list returned by bladerf_get_device_list()\n\n @param[inout]    devices     List of available devices"]
    pub fn bladerf_free_device_list(devices: *mut bladerf_devinfo);
}
extern "C" {
    #[doc = " Initialize a device identifier information structure to a \"wildcard\" state.\n\n The values in each field will match any value for that field.\n\n @note Passing a bladerf_devinfo initialized with this function to\n       bladerf_open_with_devinfo() will match the first device found."]
    pub fn bladerf_init_devinfo(info: *mut bladerf_devinfo);
}
extern "C" {
    #[doc = " Fill out a provided bladerf_devinfo structure, given an open device handle.\n\n @pre `dev` must be a valid device handle.\n\n @param        dev     Device handle previously obtained with bladerf_open()\n @param[out]   info    Device information populated by this function\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_devinfo(dev: *mut bladerf, info: *mut bladerf_devinfo) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Fill out a provided bladerf_backendinfo structure, given an open device handle.\n\n @pre `dev` must be a valid device handle.\n\n @param        dev     Device handle previously obtained with bladerf_open()\n @param[out]   info    Backend information populated by this function\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_backendinfo(
        dev: *mut bladerf,
        info: *mut bladerf_backendinfo,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Populate a device identifier information structure using the provided\n device identifier string.\n\n @param[in]   devstr  Device identifier string, formated as described\n                      in the bladerf_open() documentation\n @param[out]  info    Upon success, this will be filled out according to the\n                      provided device identifier string, with wildcards for\n                      any fields that were not provided.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_devinfo_from_str(
        devstr: *const ::libc::c_char,
        info: *mut bladerf_devinfo,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Test whether two device identifier information structures match, taking\n wildcard values into account.\n\n @param[in]   a   the first bladerf_devinfo struct\n @param[in]   b   the second bladerf_devinfo struct"]
    pub fn bladerf_devinfo_matches(a: *const bladerf_devinfo, b: *const bladerf_devinfo) -> bool;
}
extern "C" {
    #[doc = " Test whether a provided device string matches a device described by\n the provided bladerf_devinfo structure\n\n @param[in]   dev_str     Devices string, formated as described in the\n                          the documentation of bladerf_open\n @param[in]   info        Device info to compare with\n\n @return  true upon a match, false otherwise"]
    pub fn bladerf_devstr_matches(
        dev_str: *const ::libc::c_char,
        info: *mut bladerf_devinfo,
    ) -> bool;
}
extern "C" {
    #[doc = " Retrieve the backend string associated with the specified\n backend enumeration value.\n\n @return A string that can used to specify the `backend` portion of a device\n         identifier string. (See bladerf_open().)"]
    pub fn bladerf_backend_str(backend: bladerf_backend) -> *const ::libc::c_char;
}
extern "C" {
    #[doc = " Enable or disable USB device reset operation upon opening a device for\n future bladerf_open() and bladerf_open_with_devinfo() calls.\n\n This operation has been found to be necessary on Linux-based systems for\n some USB 3.0 controllers on Linux.\n\n This <b>does not</b> reset the state of the device in terms of its frequency,\n gain, sample rate, etc. settings.\n\n @param[in]   enabled     Set true to enable the use of the USB device reset,\n                          and false otherwise."]
    pub fn bladerf_set_usb_reset_on_open(enabled: bool);
}
#[doc = " Range structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_range {
    #[doc = "< Minimum value"]
    pub min: i64,
    #[doc = "< Maximum value"]
    pub max: i64,
    #[doc = "< Step of value"]
    pub step: i64,
    #[doc = "< Unit scale"]
    pub scale: f32,
}
#[test]
fn bindgen_test_layout_bladerf_range() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_range> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_range>(),
        32usize,
        concat!("Size of: ", stringify!(bladerf_range))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_range>(),
        8usize,
        concat!("Alignment of ", stringify!(bladerf_range))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).min) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_range),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).max) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_range),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).step) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_range),
            "::",
            stringify!(step)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).scale) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_range),
            "::",
            stringify!(scale)
        )
    );
}
#[doc = " Serial number structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_serial {
    #[doc = "< Device serial number string"]
    pub serial: [::libc::c_char; 33usize],
}
#[test]
fn bindgen_test_layout_bladerf_serial() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_serial> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_serial>(),
        33usize,
        concat!("Size of: ", stringify!(bladerf_serial))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_serial>(),
        1usize,
        concat!("Alignment of ", stringify!(bladerf_serial))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_serial),
            "::",
            stringify!(serial)
        )
    );
}
#[doc = " Version structure for FPGA, firmware, libbladeRF, and associated utilities"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_version {
    #[doc = "< Major version"]
    pub major: u16,
    #[doc = "< Minor version"]
    pub minor: u16,
    #[doc = "< Patch version"]
    pub patch: u16,
    #[doc = "< Version string with any additional suffix\n   information.\n\n   @warning Do not attempt to modify or free()\n            this string."]
    pub describe: *const ::libc::c_char,
}
#[test]
fn bindgen_test_layout_bladerf_version() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_version> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_version>(),
        16usize,
        concat!("Size of: ", stringify!(bladerf_version))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_version>(),
        8usize,
        concat!("Alignment of ", stringify!(bladerf_version))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).major) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_version),
            "::",
            stringify!(major)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).minor) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_version),
            "::",
            stringify!(minor)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).patch) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_version),
            "::",
            stringify!(patch)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).describe) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_version),
            "::",
            stringify!(describe)
        )
    );
}
#[doc = "< Unable to determine FPGA variant"]
pub const bladerf_fpga_size_BLADERF_FPGA_UNKNOWN: bladerf_fpga_size = 0;
#[doc = "< 40 kLE FPGA"]
pub const bladerf_fpga_size_BLADERF_FPGA_40KLE: bladerf_fpga_size = 40;
#[doc = "< 115 kLE FPGA"]
pub const bladerf_fpga_size_BLADERF_FPGA_115KLE: bladerf_fpga_size = 115;
#[doc = "< 49 kLE FPGA (A4)"]
pub const bladerf_fpga_size_BLADERF_FPGA_A4: bladerf_fpga_size = 49;
#[doc = "< 77 kLE FPGA (A5)"]
pub const bladerf_fpga_size_BLADERF_FPGA_A5: bladerf_fpga_size = 77;
#[doc = "< 301 kLE FPGA (A9)"]
pub const bladerf_fpga_size_BLADERF_FPGA_A9: bladerf_fpga_size = 301;
#[doc = " FPGA device variant (size)"]
pub type bladerf_fpga_size = ::libc::c_uint;
pub const bladerf_dev_speed_BLADERF_DEVICE_SPEED_UNKNOWN: bladerf_dev_speed = 0;
pub const bladerf_dev_speed_BLADERF_DEVICE_SPEED_HIGH: bladerf_dev_speed = 1;
pub const bladerf_dev_speed_BLADERF_DEVICE_SPEED_SUPER: bladerf_dev_speed = 2;
#[doc = " This enum describes the USB Speed at which the bladeRF is connected.\n Speeds not listed here are not supported."]
pub type bladerf_dev_speed = ::libc::c_uint;
#[doc = "< Uninitialized/invalid"]
pub const bladerf_fpga_source_BLADERF_FPGA_SOURCE_UNKNOWN: bladerf_fpga_source = 0;
#[doc = "< Last FPGA load was from flash"]
pub const bladerf_fpga_source_BLADERF_FPGA_SOURCE_FLASH: bladerf_fpga_source = 1;
#[doc = "< Last FPGA load was from host"]
pub const bladerf_fpga_source_BLADERF_FPGA_SOURCE_HOST: bladerf_fpga_source = 2;
#[doc = " FPGA configuration source\n\n Note: the numbering of this enum must match NuandFpgaConfigSource in\n firmware_common/bladeRF.h"]
pub type bladerf_fpga_source = ::libc::c_uint;
extern "C" {
    #[doc = " Query a device's serial number (deprecated)\n\n @param       dev     Device handle\n @param[out]  serial  This user-supplied buffer, which <b>must be at least\n                      ::BLADERF_SERIAL_LENGTH bytes</b>, will be updated to\n                      contain a NUL-terminated serial number string. If an\n                      error occurs (as indicated by a non-zero return value),\n                      no data will be written to this buffer.\n\n @deprecated New code should use ::bladerf_get_serial_struct instead.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_serial(dev: *mut bladerf, serial: *mut ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Query a device's serial number\n\n @param       dev     Device handle\n @param[out]  serial  Pointer to a bladerf_serial structure, which will be\n                      populated with a `serial` string on success.\n\n Example code:\n\n @code\n   struct bladerf_serial sn;\n\n   status = bladerf_get_serial_struct(dev, &sn);\n   if (status < 0) {\n       // error handling here\n   }\n\n   printf(\"Serial number: %s\\n\", sn.serial);\n @endcode\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_serial_struct(
        dev: *mut bladerf,
        serial: *mut bladerf_serial,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Query a device's FPGA size\n\n @param       dev     Device handle\n @param[out]  size    Will be updated with the on-board FPGA's size. If an\n                      error occurs, no data will be written to this pointer.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_fpga_size(dev: *mut bladerf, size: *mut bladerf_fpga_size) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Query a device's expected FPGA bitstream length, in bytes\n\n @param       dev     Device handle\n @param[out]  size    Will be updated with expected bitstream length. If an\n                      error occurs, no data will be written to this pointer.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_fpga_bytes(dev: *mut bladerf, size: *mut usize) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Query a device's Flash size\n\n @param       dev      Device handle\n @param[out]  size     Will be updated with the size of the onboard flash,\n                       in bytes. If an error occurs, no data will be written\n                       to this pointer.\n @param[out]  is_guess True if the flash size is a guess (using FPGA size).\n                       False if the flash ID was queried and its size\n                       was successfully decoded.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_flash_size(
        dev: *mut bladerf,
        size: *mut u32,
        is_guess: *mut bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Query firmware version\n\n @param       dev         Device handle\n @param[out]  version     Updated to contain firmware version\n\n @return 0 on success, value from \\ref RETCODES list upon failing to retrieve\n         this information from the device."]
    pub fn bladerf_fw_version(dev: *mut bladerf, version: *mut bladerf_version) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Check FPGA configuration status\n\n @param       dev         Device handle\n\n @return 1 if FPGA is configured, 0 if it is not,\n         and value from \\ref RETCODES list on failure"]
    pub fn bladerf_is_fpga_configured(dev: *mut bladerf) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Query FPGA version\n\n @param       dev         Device handle\n @param[out]  version     Updated to contain firmware version\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_fpga_version(dev: *mut bladerf, version: *mut bladerf_version) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Query FPGA configuration source\n\n Determine whether the FPGA image was loaded from flash, or if it was\n loaded from the host, by asking the firmware for the last-known FPGA\n configuration source.\n\n @param       dev     Device handle\n @param[out]  source  Source of the configuration\n\n @return 0 on success, ::BLADERF_ERR_UNSUPPORTED if the\n BLADERF_CAP_FW_FPGA_SOURCE capability is not present, value from \\ref\n RETCODES list on failure"]
    pub fn bladerf_get_fpga_source(
        dev: *mut bladerf,
        source: *mut bladerf_fpga_source,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Obtain the bus speed at which the device is operating\n\n @param       dev     Device handle\n\n @return Device speed enumeration"]
    pub fn bladerf_device_speed(dev: *mut bladerf) -> bladerf_dev_speed;
}
extern "C" {
    #[doc = " Get the board name\n\n @param       dev     Device handle\n\n @return Pointer to C string with the board's model name, either `bladerf1`\n         for a bladeRF x40/x115, or `bladerf2` for a bladeRF Micro."]
    pub fn bladerf_get_board_name(dev: *mut bladerf) -> *const ::libc::c_char;
}
#[doc = " Channel type\n\n Example usage:\n\n @code{.c}\n // RX Channel 0\n bladerf_channel ch = BLADERF_CHANNEL_RX(0);\n\n // RX Channel 1\n bladerf_channel ch = BLADERF_CHANNEL_RX(1);\n\n // TX Channel 0\n bladerf_channel ch = BLADERF_CHANNEL_TX(0);\n\n // TX Channel 1\n bladerf_channel ch = BLADERF_CHANNEL_TX(1);\n @endcode"]
pub type bladerf_channel = ::libc::c_int;
#[doc = " @cond IGNORE"]
pub type bladerf_module = bladerf_channel;
#[doc = "< Receive direction"]
pub const bladerf_direction_BLADERF_RX: bladerf_direction = 0;
#[doc = "< Transmit direction"]
pub const bladerf_direction_BLADERF_TX: bladerf_direction = 1;
#[doc = " Stream direction"]
pub type bladerf_direction = ::libc::c_uint;
#[doc = "< x1 RX (SISO)"]
pub const bladerf_channel_layout_BLADERF_RX_X1: bladerf_channel_layout = 0;
#[doc = "< x1 TX (SISO)"]
pub const bladerf_channel_layout_BLADERF_TX_X1: bladerf_channel_layout = 1;
#[doc = "< x2 RX (MIMO)"]
pub const bladerf_channel_layout_BLADERF_RX_X2: bladerf_channel_layout = 2;
#[doc = "< x2 TX (MIMO)"]
pub const bladerf_channel_layout_BLADERF_TX_X2: bladerf_channel_layout = 3;
#[doc = " Stream channel layout"]
pub type bladerf_channel_layout = ::libc::c_uint;
extern "C" {
    #[doc = " Get the number of RX or TX channels supported by the given device\n\n @param       dev     Device handle\n @param[in]   dir     Stream direction\n\n @return Number of channels"]
    pub fn bladerf_get_channel_count(dev: *mut bladerf, dir: bladerf_direction) -> usize;
}
#[doc = " Gain value, in decibels (dB)\n\n May be positive or negative."]
pub type bladerf_gain = ::libc::c_int;
#[doc = " Device-specific default (automatic, when available)\n\n On the bladeRF x40 and x115 with FPGA versions >= v0.7.0, this is\n automatic gain control.\n\n On the bladeRF 2.0 Micro, this is BLADERF_GAIN_SLOWATTACK_AGC with\n reasonable default settings."]
pub const bladerf_gain_mode_BLADERF_GAIN_DEFAULT: bladerf_gain_mode = 0;
#[doc = " Manual gain control\n\n Available on all bladeRF models."]
pub const bladerf_gain_mode_BLADERF_GAIN_MGC: bladerf_gain_mode = 1;
#[doc = " Automatic gain control, fast attack (advanced)\n\n Only available on the bladeRF 2.0 Micro. This is an advanced option, and\n typically requires additional configuration for ideal performance."]
pub const bladerf_gain_mode_BLADERF_GAIN_FASTATTACK_AGC: bladerf_gain_mode = 2;
#[doc = " Automatic gain control, slow attack (advanced)\n\n Only available on the bladeRF 2.0 Micro. This is an advanced option, and\n typically requires additional configuration for ideal performance."]
pub const bladerf_gain_mode_BLADERF_GAIN_SLOWATTACK_AGC: bladerf_gain_mode = 3;
#[doc = " Automatic gain control, hybrid attack (advanced)\n\n Only available on the bladeRF 2.0 Micro. This is an advanced option, and\n typically requires additional configuration for ideal performance."]
pub const bladerf_gain_mode_BLADERF_GAIN_HYBRID_AGC: bladerf_gain_mode = 4;
#[doc = " Gain control modes\n\n In general, the default mode is automatic gain control. This will\n continuously adjust the gain to maximize dynamic range and minimize clipping.\n\n @note Implementers are encouraged to simply present a boolean choice between\n       \"AGC On\" (::BLADERF_GAIN_DEFAULT) and \"AGC Off\" (::BLADERF_GAIN_MGC).\n       The remaining choices are for advanced use cases."]
pub type bladerf_gain_mode = ::libc::c_uint;
#[doc = " Mapping between C string description of gain modes and bladerf_gain_mode"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_gain_modes {
    #[doc = "< Name of gain mode"]
    pub name: *const ::libc::c_char,
    #[doc = "< Gain mode enumeration"]
    pub mode: bladerf_gain_mode,
}
#[test]
fn bindgen_test_layout_bladerf_gain_modes() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_gain_modes> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_gain_modes>(),
        16usize,
        concat!("Size of: ", stringify!(bladerf_gain_modes))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_gain_modes>(),
        8usize,
        concat!("Alignment of ", stringify!(bladerf_gain_modes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_gain_modes),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_gain_modes),
            "::",
            stringify!(mode)
        )
    );
}
extern "C" {
    #[doc = " Set overall system gain\n\n This sets an overall system gain, optimally proportioning the gain between\n multiple gain stages if applicable.\n\n @see Use bladerf_get_gain_range() to determine the range of system gain.\n\n On receive channels, 60 dB is the maximum gain level.\n\n On transmit channels, 60 dB is defined as approximately 0 dBm. Note that\n this is not a calibrated value, and the actual output power will vary based\n on a multitude of factors.\n\n @todo The gain ranges are not shifted to account for external accessories,\n       such as amplifiers and LNAs.\n\n @note Values outside the valid gain range will be clamped.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   gain        Desired gain, in dB\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_gain(
        dev: *mut bladerf,
        ch: bladerf_channel,
        gain: bladerf_gain,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get overall system gain\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  gain        Gain, in dB\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_gain(
        dev: *mut bladerf,
        ch: bladerf_channel,
        gain: *mut bladerf_gain,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set gain control mode\n\n Sets the mode for hardware AGC. Not all channels or boards will support\n all possible values (e.g. transmit channels); invalid combinations will\n return ::BLADERF_ERR_UNSUPPORTED.\n\n The special value of ::BLADERF_GAIN_DEFAULT will return hardware AGC to\n its default value at initialization.\n\n @see bladerf_gain_mode for implementation guidance\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   mode        Desired gain mode\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_gain_mode(
        dev: *mut bladerf,
        ch: bladerf_channel,
        mode: bladerf_gain_mode,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get gain control mode\n\n Gets the current mode for hardware AGC. If the channel or board does not\n meaningfully have a gain mode (e.g. transmit channels), mode will be\n set to ::BLADERF_GAIN_DEFAULT and `0` will be returned.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  mode        Gain mode\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_gain_mode(
        dev: *mut bladerf,
        ch: bladerf_channel,
        mode: *mut bladerf_gain_mode,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get available gain control modes\n\n Populates `modes` with a pointer to an array of structs containing the\n supported gain modes.\n\n This function may be called with `NULL` for `modes` to determine the number\n of gain modes supported.\n\n @see bladerf_gain_mode for implementation guidance\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  modes       Supported gain modes\n\n @return Number of gain modes on success, value from \\ref RETCODES list on\n         failure"]
    pub fn bladerf_get_gain_modes(
        dev: *mut bladerf,
        ch: bladerf_channel,
        modes: *mut *const bladerf_gain_modes,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get range of overall system gain\n\n @note This may vary depending on the configured frequency, so it should be\n       checked after setting the desired frequency.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  range       Gain range\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_gain_range(
        dev: *mut bladerf,
        ch: bladerf_channel,
        range: *mut *const bladerf_range,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the gain for a specific gain stage\n\n @note Values outside the valid gain range will be clipped.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   stage       Gain stage name\n @param[in]   gain        Desired gain\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_gain_stage(
        dev: *mut bladerf,
        ch: bladerf_channel,
        stage: *const ::libc::c_char,
        gain: bladerf_gain,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the gain for a specific gain stage\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   stage       Gain stage name\n @param[out]  gain        Gain\n\n Note that, in some cases, gain may be negative (e.g. transmit channels).\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_gain_stage(
        dev: *mut bladerf,
        ch: bladerf_channel,
        stage: *const ::libc::c_char,
        gain: *mut bladerf_gain,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get gain range of a specific gain stage\n\n @note This may vary depending on the configured frequency, so it should be\n       checked after setting the desired frequency.\n\n This function may be called with `NULL` for `range` to test if a given gain\n range exists.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   stage       Gain stage name\n @param[out]  range       Gain range\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_gain_stage_range(
        dev: *mut bladerf,
        ch: bladerf_channel,
        stage: *const ::libc::c_char,
        range: *mut *const bladerf_range,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get a list of available gain stages\n\n This function may be called with `NULL` for `stages`, or 0 for `count`, to\n determine the number of gain stages.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  stages      Gain stage names\n @param[out]  count       Number to populate\n\n @return Number of gain stages on success, value from \\ref RETCODES list on\n         failure"]
    pub fn bladerf_get_gain_stages(
        dev: *mut bladerf,
        ch: bladerf_channel,
        stages: *mut *const ::libc::c_char,
        count: usize,
    ) -> ::libc::c_int;
}
#[doc = " Sample rate, in samples per second (sps)"]
pub type bladerf_sample_rate = ::libc::c_uint;
#[doc = " Rational sample rate representation\n\n Sample rates are in the form of\n @f[\n  rate = integer + \\frac{num}{den}\n @f]"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_rational_rate {
    #[doc = "< Integer portion"]
    pub integer: u64,
    #[doc = "< Numerator in fractional portion"]
    pub num: u64,
    #[doc = "< Denominator in fractional portion. This must be\n   greater than 0."]
    pub den: u64,
}
#[test]
fn bindgen_test_layout_bladerf_rational_rate() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_rational_rate> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_rational_rate>(),
        24usize,
        concat!("Size of: ", stringify!(bladerf_rational_rate))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_rational_rate>(),
        8usize,
        concat!("Alignment of ", stringify!(bladerf_rational_rate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).integer) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_rational_rate),
            "::",
            stringify!(integer)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).num) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_rational_rate),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).den) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_rational_rate),
            "::",
            stringify!(den)
        )
    );
}
extern "C" {
    #[doc = " Configure the channel's sample rate to the specified rate in Hz.\n\n @note This requires the sample rate is an integer value of Hz.  Use\n       bladerf_set_rational_sample_rate() for more arbitrary values.\n\n @see Use bladerf_get_sample_rate_range() to determine the range of supported\n      sample rates.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   rate        Sample rate\n @param[out]  actual      If non-NULL, this is written with the actual\n                          sample rate achieved.\n\n @return 0 on success, value from \\ref RETCODES list upon failure"]
    pub fn bladerf_set_sample_rate(
        dev: *mut bladerf,
        ch: bladerf_channel,
        rate: bladerf_sample_rate,
        actual: *mut bladerf_sample_rate,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Configure the channel's sample rate as a rational fraction of Hz.\n\n @see Use bladerf_get_sample_rate_range() to determine the range of supported\n      sample rates.\n\n @param       dev         Device handle\n @param[in]   ch          Channel to change\n @param[in]   rate        Rational sample rate\n @param[out]  actual      If non-NULL, this is written with the actual\n                          rational sample rate achieved.\n\n @return 0 on success, value from \\ref RETCODES list upon failure"]
    pub fn bladerf_set_rational_sample_rate(
        dev: *mut bladerf,
        ch: bladerf_channel,
        rate: *mut bladerf_rational_rate,
        actual: *mut bladerf_rational_rate,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the channel's current sample rate in Hz\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  rate        Current sample rate\n\n @return 0 on success, value from \\ref RETCODES list upon failure"]
    pub fn bladerf_get_sample_rate(
        dev: *mut bladerf,
        ch: bladerf_channel,
        rate: *mut bladerf_sample_rate,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the channel's supported range of sample rates\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  range       Sample rate range\n\n @return 0 on success, value from \\ref RETCODES list upon failure"]
    pub fn bladerf_get_sample_rate_range(
        dev: *mut bladerf,
        ch: bladerf_channel,
        range: *mut *const bladerf_range,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the channel's sample rate in rational Hz\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  rate        Current rational sample rate\n\n @return 0 on success, value from \\ref RETCODES list upon failure"]
    pub fn bladerf_get_rational_sample_rate(
        dev: *mut bladerf,
        ch: bladerf_channel,
        rate: *mut bladerf_rational_rate,
    ) -> ::libc::c_int;
}
#[doc = " Bandwidth, in hertz (Hz)"]
pub type bladerf_bandwidth = ::libc::c_uint;
extern "C" {
    #[doc = " Set the bandwidth of the channel to the specified value in Hz\n\n The underlying device is capable of a discrete set of bandwidth values. The\n caller should check the `actual` parameter to determine which of these\n discrete bandwidth values is actually used for the requested bandwidth.\n\n @see Use bladerf_get_bandwidth_range() to determine the range of supported\n      bandwidths.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   bandwidth   Desired bandwidth\n @param[out]  actual      If non-NULL, written with the actual bandwidth that\n                          the device was able to achieve.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_bandwidth(
        dev: *mut bladerf,
        ch: bladerf_channel,
        bandwidth: bladerf_bandwidth,
        actual: *mut bladerf_bandwidth,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the bandwidth of the channel\n\n @param       dev         Device Handle\n @param[in]   ch          Channel\n @param[out]  bandwidth   Actual bandwidth in Hz\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_bandwidth(
        dev: *mut bladerf,
        ch: bladerf_channel,
        bandwidth: *mut bladerf_bandwidth,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the supported range of bandwidths for a channel\n\n @param       dev         Device Handle\n @param[in]   ch          Channel\n @param[out]  range       Bandwidth range\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_bandwidth_range(
        dev: *mut bladerf,
        ch: bladerf_channel,
        range: *mut *const bladerf_range,
    ) -> ::libc::c_int;
}
#[doc = " RF center frequency, in hertz (Hz)\n\n @see Format macros for fprintf() and fscanf(): `BLADERF_PRIuFREQ`,\n `BLADERF_PRIxFREQ`, `BLADERF_SCNuFREQ`, `BLADERF_SCNxFREQ`\n\n @remark Prior to libbladeRF 2.0.0, frequencies were specified as\n         `unsigned int`."]
pub type bladerf_frequency = u64;
extern "C" {
    #[doc = " Select the appropriate band path given a frequency in Hz.\n\n @note Most API users will not need to use this function, as\n       bladerf_set_frequency() calls this internally after tuning the device.\n\n The high band is used for `frequency` above 1.5 GHz on bladeRF1 and above\n 3.0 GHz on bladeRF2. Otherwise, the low band is used.\n\n @see bladerf_get_frequency_range() to determine the range of supported\n      frequencies.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   frequency   Tuned frequency\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_select_band(
        dev: *mut bladerf,
        ch: bladerf_channel,
        frequency: bladerf_frequency,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set channel's frequency in Hz.\n\n @note On the bladeRF1 platform, it is recommended to keep the RX and TX\n       frequencies at least 1 MHz apart, and to digitally mix on the RX side\n       if reception closer to the TX frequency is required.\n\n @note On the bladeRF2, there is one oscillator for all RX channels and one\n       oscillator for all TX channels. Therefore, changing one channel will\n       change the frequency of all channels in that direction.\n\n This function calls bladerf_select_band() internally, and performs all\n other tasks required to prepare the channel for the given frequency.\n\n @see bladerf_get_frequency_range() to determine the range of supported\n      frequencies.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   frequency   Desired frequency\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_frequency(
        dev: *mut bladerf,
        ch: bladerf_channel,
        frequency: bladerf_frequency,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get channel's current frequency in Hz\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  frequency   Current frequency\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_frequency(
        dev: *mut bladerf,
        ch: bladerf_channel,
        frequency: *mut bladerf_frequency,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the supported range of frequencies for a channel\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  range       Frequency range\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_frequency_range(
        dev: *mut bladerf,
        ch: bladerf_channel,
        range: *mut *const bladerf_range,
    ) -> ::libc::c_int;
}
#[doc = " Disables loopback and returns to normal operation."]
pub const bladerf_loopback_BLADERF_LB_NONE: bladerf_loopback = 0;
#[doc = " Firmware loopback inside of the FX3"]
pub const bladerf_loopback_BLADERF_LB_FIRMWARE: bladerf_loopback = 1;
#[doc = " Baseband loopback. TXLPF output is connected to the RXVGA2 input."]
pub const bladerf_loopback_BLADERF_LB_BB_TXLPF_RXVGA2: bladerf_loopback = 2;
#[doc = " Baseband loopback. TXVGA1 output is connected to the RXVGA2 input."]
pub const bladerf_loopback_BLADERF_LB_BB_TXVGA1_RXVGA2: bladerf_loopback = 3;
#[doc = " Baseband loopback. TXLPF output is connected to the RXLPF input."]
pub const bladerf_loopback_BLADERF_LB_BB_TXLPF_RXLPF: bladerf_loopback = 4;
#[doc = " Baseband loopback. TXVGA1 output is connected to RXLPF input."]
pub const bladerf_loopback_BLADERF_LB_BB_TXVGA1_RXLPF: bladerf_loopback = 5;
#[doc = " RF loopback. The TXMIX output, through the AUX PA, is connected to the\n output of LNA1."]
pub const bladerf_loopback_BLADERF_LB_RF_LNA1: bladerf_loopback = 6;
#[doc = " RF loopback. The TXMIX output, through the AUX PA, is connected to the\n output of LNA2."]
pub const bladerf_loopback_BLADERF_LB_RF_LNA2: bladerf_loopback = 7;
#[doc = " RF loopback. The TXMIX output, through the AUX PA, is connected to the\n output of LNA3."]
pub const bladerf_loopback_BLADERF_LB_RF_LNA3: bladerf_loopback = 8;
#[doc = " RFIC digital loopback (built-in self-test)"]
pub const bladerf_loopback_BLADERF_LB_RFIC_BIST: bladerf_loopback = 9;
#[doc = " Loopback options"]
pub type bladerf_loopback = ::libc::c_uint;
#[doc = " Mapping of human-readable names to loopback modes"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_loopback_modes {
    #[doc = "< Name of loopback mode"]
    pub name: *const ::libc::c_char,
    #[doc = "< Loopback mode enumeration"]
    pub mode: bladerf_loopback,
}
#[test]
fn bindgen_test_layout_bladerf_loopback_modes() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_loopback_modes> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_loopback_modes>(),
        16usize,
        concat!("Size of: ", stringify!(bladerf_loopback_modes))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_loopback_modes>(),
        8usize,
        concat!("Alignment of ", stringify!(bladerf_loopback_modes))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).name) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_loopback_modes),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).mode) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_loopback_modes),
            "::",
            stringify!(mode)
        )
    );
}
extern "C" {
    #[doc = " Get loopback modes\n\n Populates `modes` with a pointer to an array of structs containing the\n supported loopback modes.\n\n This function may be called with `NULL` for `modes` to determine the number\n of loopback modes supported.\n\n @param       dev         Device handle\n @param[out]  modes       Supported loopback modes\n\n @return Number of loopback modes on success, value from \\ref RETCODES list\n         on failure"]
    pub fn bladerf_get_loopback_modes(
        dev: *mut bladerf,
        modes: *mut *const bladerf_loopback_modes,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Test if a given loopback mode is supported on this device.\n\n @param       dev         Device handle\n @param[in]   mode        bladerf_loopback enum to check\n\n @return true if supported, false if not (or on error)"]
    pub fn bladerf_is_loopback_mode_supported(dev: *mut bladerf, mode: bladerf_loopback) -> bool;
}
extern "C" {
    #[doc = " Apply specified loopback mode\n\n @note Loopback modes should only be enabled or disabled while the RX and TX\n       channels are both disabled (and therefore, when no samples are being\n       actively streamed). Otherwise, unexpected behavior may occur.\n\n @param       dev     Device handle\n @param[in]   lb      Loopback mode. Note that BLADERF_LB_NONE disables the\n                      use of loopback functionality.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_loopback(dev: *mut bladerf, lb: bladerf_loopback) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get current loopback mode\n\n @param       dev     Device handle\n @param[out]  lb      Current loopback mode\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_loopback(dev: *mut bladerf, lb: *mut bladerf_loopback) -> ::libc::c_int;
}
#[doc = " Invalid role selection"]
pub const bladerf_trigger_role_BLADERF_TRIGGER_ROLE_INVALID: bladerf_trigger_role = -1;
#[doc = " Triggering functionality is disabled on this device. Samples are not\n gated and the trigger signal is an input."]
pub const bladerf_trigger_role_BLADERF_TRIGGER_ROLE_DISABLED: bladerf_trigger_role = 0;
#[doc = " This device is the trigger master. Its trigger signal will be an output\n and this device will determine when all devices shall trigger."]
pub const bladerf_trigger_role_BLADERF_TRIGGER_ROLE_MASTER: bladerf_trigger_role = 1;
#[doc = " This device is the trigger slave. This device's trigger signal will be an\n input and this devices will wait for the master's trigger signal\n assertion."]
pub const bladerf_trigger_role_BLADERF_TRIGGER_ROLE_SLAVE: bladerf_trigger_role = 2;
#[doc = " This value denotes the role of a device in a trigger chain."]
pub type bladerf_trigger_role = ::libc::c_int;
#[doc = "< Invalid selection"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_INVALID: bladerf_trigger_signal = -1;
#[doc = "< J71 pin 4, mini_exp[1] on x40/x115"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_J71_4: bladerf_trigger_signal = 0;
#[doc = "< J51 pin 1, mini_exp[1] on xA4/xA5/xA9"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_J51_1: bladerf_trigger_signal = 1;
#[doc = "< mini_exp[1], hardware-independent"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_MINI_EXP_1: bladerf_trigger_signal = 2;
#[doc = "< Reserved for user SW/HW customizations"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_USER_0: bladerf_trigger_signal = 128;
#[doc = "< Reserved for user SW/HW customizations"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_USER_1: bladerf_trigger_signal = 129;
#[doc = "< Reserved for user SW/HW customizations"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_USER_2: bladerf_trigger_signal = 130;
#[doc = "< Reserved for user SW/HW customizations"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_USER_3: bladerf_trigger_signal = 131;
#[doc = "< Reserved for user SW/HW customizations"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_USER_4: bladerf_trigger_signal = 132;
#[doc = "< Reserved for user SW/HW customizations"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_USER_5: bladerf_trigger_signal = 133;
#[doc = "< Reserved for user SW/HW customizations"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_USER_6: bladerf_trigger_signal = 134;
#[doc = "< Reserved for user SW/HW customizations"]
pub const bladerf_trigger_signal_BLADERF_TRIGGER_USER_7: bladerf_trigger_signal = 135;
#[doc = " Trigger signal selection\n\n This selects pin or signal used for the trigger.\n\n @note ::BLADERF_TRIGGER_J71_4, ::BLADERF_TRIGGER_J51_1, and\n       ::BLADERF_TRIGGER_MINI_EXP_1 are the only valid options as of FPGA\n       v0.6.0. All three values have the same behavior and may be used\n       interchangably.\n\n The `BLADERF_TRIGGER_USER_*` values have been added to allow users to modify\n both hardware and software implementations to add custom triggers, while\n maintaining libbladeRF API compatibility. Official bladeRF releases will\n not utilize these user signal IDs."]
pub type bladerf_trigger_signal = ::libc::c_int;
#[doc = " Trigger configuration\n\n It is <b>highly recommended</b> to keep a 1:1 relationship between triggers\n in the physical setup and instances of this structure. (i.e., do not re-use\n and change the same bladerf_trigger) for multiple triggers.)"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_trigger {
    #[doc = "< RX/TX channel associated with trigger"]
    pub channel: bladerf_channel,
    #[doc = "< Role of the device in a trigger chain"]
    pub role: bladerf_trigger_role,
    #[doc = "< Pin or signal being used"]
    pub signal: bladerf_trigger_signal,
    #[doc = "< Reserved field for future options. This\n   is unused and should be set to 0."]
    pub options: u64,
}
#[test]
fn bindgen_test_layout_bladerf_trigger() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_trigger> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_trigger>(),
        24usize,
        concat!("Size of: ", stringify!(bladerf_trigger))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_trigger>(),
        8usize,
        concat!("Alignment of ", stringify!(bladerf_trigger))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).channel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_trigger),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).role) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_trigger),
            "::",
            stringify!(role)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).signal) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_trigger),
            "::",
            stringify!(signal)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).options) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_trigger),
            "::",
            stringify!(options)
        )
    );
}
extern "C" {
    #[doc = " Initialize a bladerf_trigger structure based upon the current configuration\n of the specified trigger signal.\n\n While it is possible to simply declare and manually fill in a bladerf_trigger\n structure, it is recommended to use this function to retrieve the current\n `role` and `options` values.\n\n @param       dev         Device to query\n @param[in]   ch          Channel\n @param[in]   signal      Trigger signal to query\n @param[out]  trigger     Updated to describe trigger\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_trigger_init(
        dev: *mut bladerf,
        ch: bladerf_channel,
        signal: bladerf_trigger_signal,
        trigger: *mut bladerf_trigger,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Configure and (dis)arm a trigger on the specified device.\n\n @note If trigger->role is set to ::BLADERF_TRIGGER_ROLE_DISABLED, this will\n       inherently disarm an armed trigger and clear any fire requests,\n       regardless of the value of `arm`.\n\n @param       dev     Device to configure\n @param[in]   trigger Trigger configure\n @param[in]   arm     (Re)Arm trigger if true, disarm if false\n @param[in]   resv1   Reserved for future use. Set to 0.\n @param[in]   resv2   Reserved for future use. Set to 0.\n\n @warning Configuring two devices in the trigger chain (or both RX and TX on a\n          single device) as masters can damage the associated FPGA pins, as\n          this would cause contention over the trigger signal. <b>Ensure only\n          one device in the chain is configured as the master!</b>\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_trigger_arm(
        dev: *mut bladerf,
        trigger: *const bladerf_trigger,
        arm: bool,
        resv1: u64,
        resv2: u64,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Fire a trigger event.\n\n Calling this functiona with a trigger whose role is anything other than\n ::BLADERF_TRIGGER_REG_MASTER will yield a BLADERF_ERR_INVAL return value.\n\n @param       dev         Device handle\n @param[in]   trigger     Trigger to assert\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_trigger_fire(
        dev: *mut bladerf,
        trigger: *const bladerf_trigger,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Query the fire request status of a master trigger\n\n @param       dev             Device handle\n @param[in]   trigger         Trigger to query\n @param[out]  is_armed        Set to true if the trigger is armed, and false\n                              otherwise. May be NULL.\n @param[out]  has_fired       Set to true if the trigger has fired, and false\n                              otherwise. May be NULL.\n @param[out]  fire_requested  Only applicable to a trigger master.\n                              Set to true if a fire request has been\n                              previously submitted. May be NULL.\n @param[out]  resv1           Reserved for future use.\n                              This field is written as 0 if not set to NULL.\n @param[out]  resv2           Reserved for future use.\n                              This field is written as 0 if not set to NULL.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_trigger_state(
        dev: *mut bladerf,
        trigger: *const bladerf_trigger,
        is_armed: *mut bool,
        has_fired: *mut bool,
        fire_requested: *mut bool,
        resv1: *mut u64,
        resv2: *mut u64,
    ) -> ::libc::c_int;
}
#[doc = " Invalid RX Mux mode selection"]
pub const bladerf_rx_mux_BLADERF_RX_MUX_INVALID: bladerf_rx_mux = -1;
#[doc = " Read baseband samples. This is the default mode of operation."]
pub const bladerf_rx_mux_BLADERF_RX_MUX_BASEBAND: bladerf_rx_mux = 0;
#[doc = " Read samples from 12 bit counters.\n\n The I channel counts up while the Q channel counts down."]
pub const bladerf_rx_mux_BLADERF_RX_MUX_12BIT_COUNTER: bladerf_rx_mux = 1;
#[doc = " Read samples from a 32 bit up-counter.\n\n I and Q form a little-endian value."]
pub const bladerf_rx_mux_BLADERF_RX_MUX_32BIT_COUNTER: bladerf_rx_mux = 2;
#[doc = " Read samples from the baseband TX input to the FPGA (from the host)"]
pub const bladerf_rx_mux_BLADERF_RX_MUX_DIGITAL_LOOPBACK: bladerf_rx_mux = 4;
#[doc = " RX Mux modes\n\n These values describe the source of samples to the RX FIFOs in the FPGA.\n They map directly to rx_mux_mode_t inside the FPGA's source code."]
pub type bladerf_rx_mux = ::libc::c_int;
extern "C" {
    #[doc = " Set the current RX Mux mode\n\n @param       dev     Device handle\n @param[in]   mux     Mux mode.\n\n @returns 0 on success, value from \\ref RETCODES list on failure."]
    pub fn bladerf_set_rx_mux(dev: *mut bladerf, mux: bladerf_rx_mux) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Gets the current RX Mux mode\n\n @param       dev     Device handle\n @param[out]  mode    Current RX Mux mode\n\n @returns 0 on success, value from \\ref RETCODES list on failure."]
    pub fn bladerf_get_rx_mux(dev: *mut bladerf, mode: *mut bladerf_rx_mux) -> ::libc::c_int;
}
#[doc = " @ingroup STREAMING\n\n Timestamp, in ticks\n\n A channel's timestamp typically increments at the sample rate.\n\n @see Format macros for fprintf() and fscanf(): `BLADERF_PRIuTS`,\n `BLADERF_PRIxTS`, `BLADERF_SCNuTS`, `BLADERF_SCNxTS`"]
pub type bladerf_timestamp = u64;
#[doc = " Quick Re-tune parameters.\n\n @note These parameters, which are associated with the RFIC's register values,\n       are sensitive to changes in the operating environment (e.g.,\n       temperature).\n\n This structure should be filled in via bladerf_get_quick_tune()."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct bladerf_quick_tune {
    pub __bindgen_anon_1: bladerf_quick_tune__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union bladerf_quick_tune__bindgen_ty_1 {
    pub __bindgen_anon_1: bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1,
    pub __bindgen_anon_2: bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1 {
    #[doc = "< Choice of VCO and VCO division factor"]
    pub freqsel: u8,
    #[doc = "< VCOCAP value"]
    pub vcocap: u8,
    #[doc = "< Integer portion of LO frequency value"]
    pub nint: u16,
    #[doc = "< Fractional portion of LO frequency value"]
    pub nfrac: u32,
    #[doc = "< Flag bits used internally by libbladeRF"]
    pub flags: u8,
    #[doc = "< Flag bits used to configure XB"]
    pub xb_gpio: u8,
}
#[test]
fn bindgen_test_layout_bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).freqsel) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(freqsel)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).vcocap) as usize - ptr as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(vcocap)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nint) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(nint)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nfrac) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(nfrac)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).xb_gpio) as usize - ptr as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(xb_gpio)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2 {
    #[doc = "< Profile number in Nios"]
    pub nios_profile: u16,
    #[doc = "< Profile number in RFFE"]
    pub rffe_profile: u8,
    #[doc = "< RFFE port settings"]
    pub port: u8,
    #[doc = "< External SPDT settings"]
    pub spdt: u8,
}
#[test]
fn bindgen_test_layout_bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2>(),
        6usize,
        concat!(
            "Size of: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2>(),
        2usize,
        concat!(
            "Alignment of ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).nios_profile) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(nios_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rffe_profile) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(rffe_profile)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).port) as usize - ptr as usize },
        3usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).spdt) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_quick_tune__bindgen_ty_1__bindgen_ty_2),
            "::",
            stringify!(spdt)
        )
    );
}
#[test]
fn bindgen_test_layout_bladerf_quick_tune__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<bladerf_quick_tune__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(bladerf_quick_tune__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_quick_tune__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(bladerf_quick_tune__bindgen_ty_1)
        )
    );
}
#[test]
fn bindgen_test_layout_bladerf_quick_tune() {
    assert_eq!(
        ::std::mem::size_of::<bladerf_quick_tune>(),
        12usize,
        concat!("Size of: ", stringify!(bladerf_quick_tune))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_quick_tune>(),
        4usize,
        concat!("Alignment of ", stringify!(bladerf_quick_tune))
    );
}
extern "C" {
    #[doc = " Schedule a frequency retune to occur at specified sample timestamp value.\n\n @pre bladerf_sync_config() must have been called with the\n      \\ref BLADERF_FORMAT_SC16_Q11_META format for the associated channel in\n      order to enable timestamps. (The timestamped metadata format must be\n      enabled in order to use this function.)\n\n @param       dev             Device handle\n @param[in]   ch              Channel\n @param[in]   timestamp       Channel's sample timestamp to perform the\n                              retune operation. If this value is in the past,\n                              the retune will occur immediately. To perform\n                              the retune immediately, specify\n                              ::BLADERF_RETUNE_NOW.\n @param[in]   frequency       Desired frequency, in Hz.\n @param[in]   quick_tune      If non-NULL, the provided \"quick retune\" values\n                              will be applied to the transceiver to tune it\n                              according to a previous state retrieved via\n                              bladerf_get_quick_tune().\n\n @return 0 on success, value from \\ref RETCODES list on failure.\n\n @note If the underlying queue of scheduled retune requests becomes full, \\ref\n       BLADERF_ERR_QUEUE_FULL will be returned. In this case, it should be\n       possible to schedule a retune after the timestamp of one of the earlier\n       requests occurs."]
    pub fn bladerf_schedule_retune(
        dev: *mut bladerf,
        ch: bladerf_channel,
        timestamp: bladerf_timestamp,
        frequency: bladerf_frequency,
        quick_tune: *mut bladerf_quick_tune,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Cancel all pending scheduled retune operations for the specified channel.\n\n This will be done automatically during bladerf_close() to ensure that\n previously queued retunes do not continue to occur after closing and then\n later re-opening a device.\n\n @param       dev     Device handle\n @param[in]   ch      Channel\n\n @return 0 on success, value from \\ref RETCODES list on failure."]
    pub fn bladerf_cancel_scheduled_retunes(
        dev: *mut bladerf,
        ch: bladerf_channel,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Fetch parameters used to tune the transceiver to the current frequency for\n use with bladerf_schedule_retune() to perform a \"quick retune.\"\n\n This allows for a faster retune, with a potential trade off of increased\n phase noise.\n\n @note These parameters are sensitive to changes in the operating environment,\n       and should be \"refreshed\" if planning to use the \"quick retune\"\n       functionality over a long period of time.\n\n @pre bladerf_set_frequency() or bladerf_schedule_retune() have previously\n      been used to retune to the desired frequency.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  quick_tune  Quick retune parameters\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_quick_tune(
        dev: *mut bladerf,
        ch: bladerf_channel,
        quick_tune: *mut bladerf_quick_tune,
    ) -> ::libc::c_int;
}
#[doc = " Correction value, in arbitrary units\n\n @see ::bladerf_correction\n @see bladerf_get_correction()\n @see bladerf_set_correction()"]
pub type bladerf_correction_value = i16;
#[doc = " Adjusts the in-phase DC offset. Valid values are [-2048, 2048], which are\n scaled to the available control bits."]
pub const bladerf_correction_BLADERF_CORR_DCOFF_I: bladerf_correction = 0;
#[doc = " Adjusts the quadrature DC offset. Valid values are [-2048, 2048], which\n are scaled to the available control bits."]
pub const bladerf_correction_BLADERF_CORR_DCOFF_Q: bladerf_correction = 1;
#[doc = " Adjusts phase correction of [-10, 10] degrees, via a provided count value\n of [-4096, 4096]."]
pub const bladerf_correction_BLADERF_CORR_PHASE: bladerf_correction = 2;
#[doc = " Adjusts gain correction value in [-1.0, 1.0], via provided values in the\n range of [-4096, 4096]."]
pub const bladerf_correction_BLADERF_CORR_GAIN: bladerf_correction = 3;
#[doc = " Correction parameter selection\n\n These values specify the correction parameter to modify or query when calling\n bladerf_set_correction() or bladerf_get_correction(). Note that the meaning\n of the `value` parameter to these functions depends upon the correction\n parameter.\n"]
pub type bladerf_correction = ::libc::c_uint;
extern "C" {
    #[doc = " Set the value of the specified configuration parameter\n\n @see The ::bladerf_correction description for the valid ranges of the `value`\n      parameter.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   corr        Correction type\n @param[in]   value       Value to apply\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_correction(
        dev: *mut bladerf,
        ch: bladerf_channel,
        corr: bladerf_correction,
        value: bladerf_correction_value,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Obtain the current value of the specified configuration parameter\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   corr        Correction type\n @param[out]  value       Current value\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_correction(
        dev: *mut bladerf,
        ch: bladerf_channel,
        corr: bladerf_correction,
        value: *mut bladerf_correction_value,
    ) -> ::libc::c_int;
}
#[doc = " Signed, Complex 16-bit Q11. This is the native format of the DAC data.\n\n Values in the range [-2048, 2048) are used to represent [-1.0, 1.0).\n Note that the lower bound here is inclusive, and the upper bound is\n exclusive. Ensure that provided samples stay within [-2048, 2047].\n\n Samples consist of interleaved IQ value pairs, with I being the first\n value in the pair. Each value in the pair is a right-aligned,\n little-endian int16_t. The FPGA ensures that these values are\n sign-extended.\n\n <pre>\n  .--------------.--------------.\n  | Bits 31...16 | Bits 15...0  |\n  +--------------+--------------+\n  |   Q[15..0]   |   I[15..0]   |\n  `--------------`--------------`\n </pre>\n\n When using this format the minimum required buffer size, in bytes, is:\n\n \\f$\n  buffer\\_size\\_min = (2 \\times num\\_samples \\times num\\_channels \\times\n                      sizeof(int16\\_t))\n \\f$\n\n For example, to hold 2048 samples for one channel, a buffer must be at\n least 8192 bytes large.\n\n When a multi-channel ::bladerf_channel_layout is selected, samples\n will be interleaved per channel. For example, with ::BLADERF_RX_X2\n or ::BLADERF_TX_X2 (x2 MIMO), the buffer is structured like:\n\n <pre>\n  .-------------.--------------.--------------.------------------.\n  | Byte offset | Bits 31...16 | Bits 15...0  |    Description   |\n  +-------------+--------------+--------------+------------------+\n  |    0x00     |     Q0[0]    |     I0[0]    |  Ch 0, sample 0  |\n  |    0x04     |     Q1[0]    |     I1[0]    |  Ch 1, sample 0  |\n  |    0x08     |     Q0[1]    |     I0[1]    |  Ch 0, sample 1  |\n  |    0x0c     |     Q1[1]    |     I1[1]    |  Ch 1, sample 1  |\n  |    ...      |      ...     |      ...     |        ...       |\n  |    0xxx     |     Q0[n]    |     I0[n]    |  Ch 0, sample n  |\n  |    0xxx     |     Q1[n]    |     I1[n]    |  Ch 1, sample n  |\n  `-------------`--------------`--------------`------------------`\n </pre>\n\n Per the `buffer_size_min` formula above, 2048 samples for two channels\n will generate 4096 total samples, and require at least 16384 bytes.\n\n Implementors may use the interleaved buffers directly, or may use\n bladerf_deinterleave_stream_buffer() / bladerf_interleave_stream_buffer()\n if contiguous blocks of samples are desired."]
pub const bladerf_format_BLADERF_FORMAT_SC16_Q11: bladerf_format = 0;
#[doc = " This format is the same as the ::BLADERF_FORMAT_SC16_Q11 format, except\n the first 4 samples in every <i>block*</i> of samples are replaced with\n metadata organized as follows. All fields are little-endian byte order.\n\n <pre>\n  .-------------.------------.----------------------------------.\n  | Byte offset |   Type     | Description                      |\n  +-------------+------------+----------------------------------+\n  |    0x00     | uint16_t   | Reserved                         |\n  |    0x02     |  uint8_t   | Stream flags                     |\n  |    0x03     |  uint8_t   | Meta version ID                  |\n  |    0x04     | uint64_t   | 64-bit Timestamp                 |\n  |    0x0c     | uint32_t   | BLADERF_META_FLAG_* flags        |\n  |  0x10..end  |            | Payload                          |\n  `-------------`------------`----------------------------------`\n </pre>\n\n For IQ sample meta mode, the Meta version ID and Stream flags should\n currently be set to values 0x00 and 0x00, respectively.\n\n <i>*</i>The number of samples in a <i>block</i> is dependent upon\n the USB speed being used:\n  - USB 2.0 Hi-Speed: 256 samples\n  - USB 3.0 SuperSpeed: 512 samples\n\n When using the bladerf_sync_rx() and bladerf_sync_tx() functions, the\n above details are entirely transparent; the caller need not be concerned\n with these details. These functions take care of packing/unpacking the\n metadata into/from the underlying stream and convey this information\n through the ::bladerf_metadata structure.\n\n However, when using the \\ref FN_STREAMING_ASYNC interface, the user is\n responsible for manually packing/unpacking the above metadata into/from\n their samples.\n\n @see STREAMING_FORMAT_METADATA\n @see The `src/streaming/metadata.h` header in the libbladeRF codebase."]
pub const bladerf_format_BLADERF_FORMAT_SC16_Q11_META: bladerf_format = 1;
#[doc = " This format is for exchanging packets containing digital payloads with\n the FPGA. A packet is generall a digital payload, that the FPGA then\n processes to either modulate, demodulate, filter, etc.\n\n All fields are little-endian byte order.\n\n <pre>\n  .-------------.------------.----------------------------------.\n  | Byte offset |   Type     | Description                      |\n  +-------------+------------+----------------------------------+\n  |    0x00     | uint16_t   | Packet length (in 32bit DWORDs)  |\n  |    0x02     |  uint8_t   | Packet flags                     |\n  |    0x03     |  uint8_t   | Packet core ID                   |\n  |    0x04     | uint64_t   | 64-bit Timestamp                 |\n  |    0x0c     | uint32_t   | BLADERF_META_FLAG_* flags        |\n  |  0x10..end  |            | Payload                          |\n  `-------------`------------`----------------------------------`\n </pre>\n\n A target core (for example a modem) must be specified when calling the\n bladerf_sync_rx() and bladerf_sync_tx() functions.\n\n When in packet mode, lengths for all functions and data formats are\n expressed in number of 32-bit DWORDs. As an example, a 12 byte packet\n is considered to be 3 32-bit DWORDs long.\n\n This packet format does not send or receive raw IQ samples. The digital\n payloads contain configurations, and digital payloads that are specific\n to the digital core to which they are addressed. It is the FPGA core\n that should generate, interpret, and process the digital payloads.\n\n With the exception of packet lenghts, no difference should exist between\n USB 2.0 Hi-Speed or USB 3.0 SuperSpeed for packets for this streaming\n format.\n\n @see STREAMING_FORMAT_METADATA\n @see The `src/streaming/metadata.h` header in the libbladeRF codebase."]
pub const bladerf_format_BLADERF_FORMAT_PACKET_META: bladerf_format = 2;
#[doc = " Signed, Complex 8-bit Q8. This is the native format of the DAC data.\n\n Values in the range [-128, 128) are used to represent [-1.0, 1.0).\n Note that the lower bound here is inclusive, and the upper bound is\n exclusive. Ensure that provided samples stay within [-128, 127].\n\n Samples consist of interleaved IQ value pairs, with I being the first\n value in the pair. Each value in the pair is a right-aligned int8_t.\n The FPGA ensures that these values are sign-extended.\n\n <pre>\n  .--------------.--------------.\n  | Bits 15...8  | Bits  7...0  |\n  +--------------+--------------+\n  |    Q[7..0]   |    I[7..0]   |\n  `--------------`--------------`\n </pre>\n\n When using this format the minimum required buffer size, in bytes, is:\n\n \\f$\n  buffer\\_size\\_min = (2 \\times num\\_samples \\times num\\_channels \\times\n                      sizeof(int8\\_t))\n \\f$\n\n For example, to hold 2048 samples for one channel, a buffer must be at\n least 4096 bytes large.\n\n When a multi-channel ::bladerf_channel_layout is selected, samples\n will be interleaved per channel. For example, with ::BLADERF_RX_X2\n or ::BLADERF_TX_X2 (x2 MIMO), the buffer is structured like:\n\n <pre>\n  .-------------.--------------.--------------.------------------.\n  | Byte offset | Bits 15...8  | Bits  7...0  |    Description   |\n  +-------------+--------------+--------------+------------------+\n  |    0x00     |     Q0[0]    |     I0[0]    |  Ch 0, sample 0  |\n  |    0x02     |     Q1[0]    |     I1[0]    |  Ch 1, sample 0  |\n  |    0x04     |     Q0[1]    |     I0[1]    |  Ch 0, sample 1  |\n  |    0x06     |     Q1[1]    |     I1[1]    |  Ch 1, sample 1  |\n  |    ...      |      ...     |      ...     |        ...       |\n  |    0xxx     |     Q0[n]    |     I0[n]    |  Ch 0, sample n  |\n  |    0xxx     |     Q1[n]    |     I1[n]    |  Ch 1, sample n  |\n  `-------------`--------------`--------------`------------------`\n </pre>\n\n Per the `buffer_size_min` formula above, 2048 samples for two channels\n will generate 4096 total samples, and require at least 8192 bytes.\n\n Implementors may use the interleaved buffers directly, or may use\n bladerf_deinterleave_stream_buffer() / bladerf_interleave_stream_buffer()\n if contiguous blocks of samples are desired."]
pub const bladerf_format_BLADERF_FORMAT_SC8_Q7: bladerf_format = 3;
#[doc = " This format is the same as the ::BLADERF_FORMAT_SC8_Q7 format, except\n the first 4 samples in every <i>block*</i> of samples are replaced with\n metadata organized as follows. All fields are little-endian byte order.\n\n <pre>\n  .-------------.------------.----------------------------------.\n  | Byte offset |   Type     | Description                      |\n  +-------------+------------+----------------------------------+\n  |    0x00     | uint16_t   | Reserved                         |\n  |    0x02     |  uint8_t   | Stream flags                     |\n  |    0x03     |  uint8_t   | Meta version ID                  |\n  |    0x04     | uint64_t   | 64-bit Timestamp                 |\n  |    0x0c     | uint32_t   | BLADERF_META_FLAG_* flags        |\n  |  0x10..end  |            | Payload                          |\n  `-------------`------------`----------------------------------`\n </pre>\n\n For IQ sample meta mode, the Meta version ID and Stream flags should\n currently be set to values 0x00 and 0x00, respectively.\n\n <i>*</i>The number of samples in a <i>block</i> is dependent upon\n the USB speed being used:\n  - USB 2.0 Hi-Speed: 256 samples\n  - USB 3.0 SuperSpeed: 512 samples\n\n When using the bladerf_sync_rx() and bladerf_sync_tx() functions, the\n above details are entirely transparent; the caller need not be concerned\n with these details. These functions take care of packing/unpacking the\n metadata into/from the underlying stream and convey this information\n through the ::bladerf_metadata structure.\n\n However, when using the \\ref FN_STREAMING_ASYNC interface, the user is\n responsible for manually packing/unpacking the above metadata into/from\n their samples.\n\n @see STREAMING_FORMAT_METADATA\n @see The `src/streaming/metadata.h` header in the libbladeRF codebase."]
pub const bladerf_format_BLADERF_FORMAT_SC8_Q7_META: bladerf_format = 4;
#[doc = " Sample format"]
pub type bladerf_format = ::libc::c_uint;
#[doc = " Sample metadata\n\n This structure is used in conjunction with the ::BLADERF_FORMAT_SC16_Q11_META\n format to TX scheduled bursts or retrieve timestamp information about\n received samples."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_metadata {
    #[doc = " Free-running FPGA counter that monotonically increases at the sample rate\n of the associated channel."]
    pub timestamp: bladerf_timestamp,
    #[doc = " Input bit field to control the behavior of the call that the metadata\n structure is passed to. API calls read this field from the provided data\n structure, and do not modify it.\n\n Valid flags include\n  ::BLADERF_META_FLAG_TX_BURST_START,\n  ::BLADERF_META_FLAG_TX_BURST_END,\n  ::BLADERF_META_FLAG_TX_NOW,\n  ::BLADERF_META_FLAG_TX_UPDATE_TIMESTAMP, and\n  ::BLADERF_META_FLAG_RX_NOW"]
    pub flags: u32,
    #[doc = " Output bit field to denoting the status of transmissions/receptions. API\n calls will write this field.\n\n Possible status flags include ::BLADERF_META_STATUS_OVERRUN and\n ::BLADERF_META_STATUS_UNDERRUN."]
    pub status: u32,
    #[doc = " This output parameter is updated to reflect the actual number of\n contiguous samples that have been populated in an RX buffer during a\n bladerf_sync_rx() call.\n\n This will not be equal to the requested count in the event of a\n discontinuity (i.e., when the status field has the\n ::BLADERF_META_STATUS_OVERRUN flag set). When an overrun occurs, it is\n important not to read past the number of samples specified by this value,\n as the remaining contents of the buffer are undefined.\n\n @note This parameter is not currently used by bladerf_sync_tx()."]
    pub actual_count: ::libc::c_uint,
    #[doc = " Reserved for future use. This is not used by any functions. It is\n recommended that users zero out this field."]
    pub reserved: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_bladerf_metadata() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_metadata> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_metadata>(),
        56usize,
        concat!("Size of: ", stringify!(bladerf_metadata))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_metadata>(),
        8usize,
        concat!("Alignment of ", stringify!(bladerf_metadata))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_metadata),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_metadata),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).status) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_metadata),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).actual_count) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_metadata),
            "::",
            stringify!(actual_count)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_metadata),
            "::",
            stringify!(reserved)
        )
    );
}
extern "C" {
    #[doc = " Interleaves contiguous blocks of samples in preparation for MIMO TX.\n\n Given a `buffer` loaded with data as such:\n\n <pre>\n  .-------------------.--------------.--------------.------------------.\n  |    Byte offset    | Bits 31...16 | Bits 15...0  |    Description   |\n  +-------------------+--------------+--------------+------------------+\n  |  0x00 + 0*chsize  |     Q0[0]    |     I0[0]    |  Ch 0, sample 0  |\n  |  0x04 + 0*chsize  |     Q0[1]    |     I0[1]    |  Ch 0, sample 1  |\n  |  0x08 + 0*chsize  |     Q0[2]    |     I0[2]    |  Ch 0, sample 2  |\n  |  0x0c + 0*chsize  |     Q0[3]    |     I0[3]    |  Ch 0, sample 3  |\n  |        ...        |      ...     |      ...     |        ...       |\n  |  0x00 + 1*chsize  |     Q1[0]    |     I1[0]    |  Ch 1, sample 0  |\n  |  0x04 + 1*chsize  |     Q1[1]    |     I1[1]    |  Ch 1, sample 1  |\n  |  0x08 + 1*chsize  |     Q1[2]    |     I1[2]    |  Ch 1, sample 2  |\n  |  0x0c + 1*chsize  |     Q1[3]    |     I1[3]    |  Ch 1, sample 3  |\n  |        ...        |      ...     |      ...     |        ...       |\n  `-------------------`--------------`--------------`------------------`\n </pre>\n\n where \\f$chsize = \\frac{sizeof(buffer)}{num\\_channels}\\f$.\n\n This function interleaves the samples in the manner described by the\n ::BLADERF_FORMAT_SC16_Q11 format, in place. Each channel must have\n \\f$buffer\\_size / num\\_channels\\f$ samples, and they must be concatenated in\n order.\n\n If the ::BLADERF_FORMAT_SC16_Q11_META format is specified, the first 16 bytes\n will skipped.\n\n This function's inverse is bladerf_deinterleave_stream_buffer().\n\n @param[in]   layout        Stream direction and layout\n @param[in]   format        Data format to use\n @param[in]   buffer_size   The size of the buffer, in samples. Note that this\n                            is the entire buffer, not just a single channel.\n @param       samples       Buffer to process. The user is responsible for\n                            ensuring this buffer contains exactly\n                            `buffer_size` samples.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_interleave_stream_buffer(
        layout: bladerf_channel_layout,
        format: bladerf_format,
        buffer_size: ::libc::c_uint,
        samples: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Deinterleaves samples into contiguous blocks after MIMO RX.\n\n This function deinterleaves a multi-channel interleaved buffer, as described\n by the ::BLADERF_FORMAT_SC16_Q11 format. The output is in the format\n described as the input to this function's inverse,\n bladerf_interleave_stream_buffer().\n\n If the ::BLADERF_FORMAT_SC16_Q11_META format is specified, the first 16 bytes\n will skipped.\n\n @param[in]   layout          Stream direction and layout\n @param[in]   format          Data format to use\n @param[in]   buffer_size     The size of the buffer, in samples. Note that\n                              this is the entire buffer, not just a single\n                              channel.\n @param       samples         Buffer to process. The user is responsible for\n                              ensuring this buffer contains exactly\n                              `buffer_size` samples.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_deinterleave_stream_buffer(
        layout: bladerf_channel_layout,
        format: bladerf_format,
        buffer_size: ::libc::c_uint,
        samples: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Enable or disable the RF front end of the specified direction.\n\n RF front ends must always be enabled prior to streaming samples on the\n associated interface.\n\n When a synchronous stream is associated with the specified channel, this will\n shut down the underlying asynchronous stream when `enable` = false.\n\n When transmitting samples, be sure to provide ample time for TX samples reach\n the RF front-end before calling this function with `enable` = false. (This\n can be achieved easily when using metadata, as shown on\n \\link sync_tx_meta_bursts.html this page\\endlink.)\n\n @param       dev     Device handle\n @param[in]   ch      Channel\n @param[in]   enable  true to enable, false to disable\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_enable_module(
        dev: *mut bladerf,
        ch: bladerf_channel,
        enable: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Retrieve the specified stream's current timestamp counter value from the\n FPGA.\n\n This function is only intended to be used to retrieve a coarse estimate of\n the current timestamp when starting up a stream. It <b>should not</b> be used\n as a means to accurately retrieve the current timestamp of individual samples\n within a running stream. The reasons for this are:\n  - The timestamp counter will have advanced during the time that the captured\n      value is propagated back from the FPGA to the host\n  - The value retrieved in this manner is not tightly-coupled with\n      specific sample positions in the stream.\n\n When actively receiving a sample stream, instead use the\n ::bladerf_metadata::timestamp field (provided when using the\n ::BLADERF_FORMAT_SC16_Q11_META format) to retrieve the timestamp value\n associated with a block of samples. See the \\link sync_rx_meta.html RX with\n metadata\\endlink page for examples of this.\n\n An example use-case of this function is to schedule an initial TX burst in a\n set of bursts:\n\n  - Configure and start a TX stream using the ::BLADERF_FORMAT_SC16_Q11_META\n      format.\n  - Retrieve timestamp \\f$T\\f$, a coarse estimate the TX's current timestamp\n      via this function.\n  - Schedule the first burst, \\f$F\\f$ to occur in the future: \\f$F = T + N\\f$.\n      Generally, adding \\f$N\\f$ in tens to low hundreds of milliseconds is\n      sufficient to account for timestamp retrieval overhead and stream\n      startup.\n  - Schedule additional bursts relative to the first burst \\f$F\\f$.\n\n Examples of the above are shown on the \\link sync_tx_meta_bursts.html TX\n with metadata\\endlink page.\n\n @param       dev         Device handle\n @param[in]   dir         Stream direction\n @param[out]  timestamp   Coarse timestamp value\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_timestamp(
        dev: *mut bladerf,
        dir: bladerf_direction,
        timestamp: *mut bladerf_timestamp,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " (Re)Configure a device for synchronous transmission or reception\n\n This function sets up the device for the specified format and initializes\n the underlying asynchronous stream parameters\n\n This function does not call bladerf_enable_module(). The API user is\n responsible for enabling/disable streams when desired.\n\n Note that (re)configuring the TX direction does not affect the RX direction,\n and vice versa. This call configures each direction independently.\n\n Memory allocated by this function will be deallocated when bladerf_close()\n is called.\n\n @see The bladerf_init_stream() documentation for information on determining\n      appropriate values for `buffers_size`, `num_transfers`, and\n      `stream_timeout`.\n\n @note The `num_buffers` parameter should generally be increased as the amount\n       of work done between bladerf_sync_rx() or bladerf_sync_tx() calls\n       increases.\n\n @param       dev             Device to configure\n @param[in]   layout          Stream direction and layout\n @param[in]   format          Format to use in synchronous data transfers\n @param[in]   num_buffers     The number of buffers to use in the underlying\n                              data stream. This must be greater than the\n                              `num_xfers` parameter.\n @param[in]   buffer_size     The size of the underlying stream buffers, in\n                              samples. This value must be a multiple of 1024.\n                              Note that samples are only transferred when a\n                              buffer of this size is filled.\n @param[in]   num_transfers   The number of active USB transfers that may be\n                              in-flight at any given time. If unsure of what\n                              to use here, try values of 4, 8, or 16.\n @param[in]   stream_timeout  Timeout (milliseconds) for transfers in the\n                              underlying data stream.\n\n @return 0 on success,\n         ::BLADERF_ERR_UNSUPPORTED if libbladeRF is not built with support\n         for this functionality,\n         or a value from \\ref RETCODES list on failures."]
    pub fn bladerf_sync_config(
        dev: *mut bladerf,
        layout: bladerf_channel_layout,
        format: bladerf_format,
        num_buffers: ::libc::c_uint,
        buffer_size: ::libc::c_uint,
        num_transfers: ::libc::c_uint,
        stream_timeout: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Transmit IQ samples.\n\n Under the hood, this call starts up an underlying asynchronous stream as\n needed. This stream can be stopped by disabling the TX channel. (See\n bladerf_enable_module for more details.)\n\n Samples will only be sent to the FPGA when a buffer have been filled. The\n number of samples required to fill a buffer corresponds to the `buffer_size`\n parameter passed to bladerf_sync_config().\n\n @pre A bladerf_sync_config() call has been to configure the device for\n      synchronous data transfer.\n\n @note A call to bladerf_enable_module() should be made before attempting to\n       transmit samples. Failing to do this may result in timeouts and other\n       errors.\n\n @param       dev         Device handle\n @param[in]   samples     Array of samples\n @param[in]   num_samples Number of samples to write\n @param[in]   metadata    Sample metadata. This must be provided when using\n                          the ::BLADERF_FORMAT_SC16_Q11_META format, but may\n                          be NULL when the interface is configured for\n                          the ::BLADERF_FORMAT_SC16_Q11 format.\n @param[in]   timeout_ms  Timeout (milliseconds) for this call to complete.\n                          Zero implies \"infinite.\"\n\n @return 0 on success,\n         ::BLADERF_ERR_UNSUPPORTED if libbladeRF is not built with support\n         for this functionality,\n         or a value from \\ref RETCODES list on failures."]
    pub fn bladerf_sync_tx(
        dev: *mut bladerf,
        samples: *const ::libc::c_void,
        num_samples: ::libc::c_uint,
        metadata: *mut bladerf_metadata,
        timeout_ms: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Receive IQ samples.\n\n Under the hood, this call starts up an underlying asynchronous stream as\n needed. This stream can be stopped by disabling the RX channel. (See\n bladerf_enable_module for more details.)\n\n @pre A bladerf_sync_config() call has been to configure the device for\n      synchronous data transfer.\n\n @note A call to bladerf_enable_module() should be made before attempting to\n       receive samples. Failing to do this may result in timeouts and other\n       errors.\n\n @param       dev         Device handle\n @param[out]  samples     Buffer to store samples in. The caller is\n                          responsible for ensuring this buffer is sufficiently\n                          large for the number of samples requested,\n                          considering the size of the sample format being\n                          used.\n @param[in]   num_samples Number of samples to read\n @param[out]  metadata    Sample metadata. This must be provided when using\n                          the ::BLADERF_FORMAT_SC16_Q11_META format, but may\n                          be NULL when the interface is configured for\n                          the ::BLADERF_FORMAT_SC16_Q11 format.\n @param[in]   timeout_ms  Timeout (milliseconds) for this call to complete.\n                          Zero implies \"infinite.\"\n\n @return 0 on success,\n         ::BLADERF_ERR_UNSUPPORTED if libbladeRF is not built with support\n         for this functionality,\n         or a value from \\ref RETCODES list on failures."]
    pub fn bladerf_sync_rx(
        dev: *mut bladerf,
        samples: *mut ::libc::c_void,
        num_samples: ::libc::c_uint,
        metadata: *mut bladerf_metadata,
        timeout_ms: ::libc::c_uint,
    ) -> ::libc::c_int;
}
#[doc = " This opaque structure is used to keep track of stream information"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_stream {
    _unused: [u8; 0],
}
#[doc = " This typedef represents a callback function that is executed in response to\n this interface's asynchronous events.\n\n Stream callbacks <b>must not</b> block or perform long-running operations.\n Otherwise, timeouts may occur. If this cannot be guaranteed, consider\n returning ::BLADERF_STREAM_NO_DATA in callbacks and later submit a buffer\n using bladerf_submit_stream_buffer(). However, callbacks should always take\n a single approach of returning buffers <b>or</b> returning\n ::BLADERF_STREAM_NO_DATA and submitting buffers later -- <b>but not both</b>.\n\n When running in a full-duplex mode of operation with simultaneous TX and RX\n stream threads, be aware that one stream's callback may occur in the context\n of another stream's thread. The API user is responsible for ensuring their\n callbacks are thread safe. For example, when managing access to sample\n buffers, the caller must ensure that if one thread is processing samples in a\n buffer, that this buffer is not returned via the callback's return value.\n\n As of libbladeRF v0.15.0, is guaranteed that only one callback from a stream\n will occur at a time. (i.e., a second TX callback will not fire while one is\n currently being handled.)  To achieve this, while a callback is executing, a\n per-stream lock is held. It is important to consider this when thinking about\n the order of lock acquisitions both in the callbacks, and the code\n surrounding bladerf_submit_stream_buffer().\n\n @note Do not call bladerf_submit_stream_buffer() from a callback.\n\n For both RX and TX, the stream callback receives:\n  - dev:          Device structure\n  - stream:       The associated stream\n  - metadata:     For future support - do not attempt to read/write this\n                  in the current library implementation.\n  - user_data:    User data provided when initializing stream\n\n For TX callbacks:\n  - samples:      Pointer to buffer of samples that was sent\n  - num_samples:  Number of sent in last transfer and to send in next transfer\n  - Return value: The user specifies the address of the next buffer to send,\n                  ::BLADERF_STREAM_SHUTDOWN, or ::BLADERF_STREAM_NO_DATA.\n\n For RX callbacks:\n  - samples:          Buffer filled with received data\n  - num_samples:      Number of samples received and size of next buffers\n  - Return value:     The user specifies the next buffer to fill with RX data,\n                      which should be `num_samples` in size,\n                      ::BLADERF_STREAM_SHUTDOWN, or ::BLADERF_STREAM_NO_DATA."]
pub type bladerf_stream_cb = ::std::option::Option<
    unsafe extern "C" fn(
        dev: *mut bladerf,
        stream: *mut bladerf_stream,
        meta: *mut bladerf_metadata,
        samples: *mut ::libc::c_void,
        num_samples: usize,
        user_data: *mut ::libc::c_void,
    ) -> *mut ::libc::c_void,
>;
extern "C" {
    #[doc = " Initialize a stream for use with asynchronous routines.\n\n This function will internally allocate data buffers, which will be provided\n to the API user in callback functions.\n\n The `buffers` output parameter populates a pointer to the list of allocated\n buffers. This allows the API user to implement a buffer management scheme to\n best suit his or her specific use case.\n\n Generally, one will want to set the `buffers` parameter to a value larger\n than the `num_transfers` parameter, and keep track of which buffers are\n currently \"in-flight\", versus those available for use.\n\n For example, for a transmit stream, modulated data can be actively written\n into free buffers while transfers of other buffers are occurring. Once a\n buffer has been filled with data, it can be marked 'in-flight' and be\n returned in a successive callback to transmit.\n\n The choice of values for the `num_transfers` and `buffer_size` should be\n made based upon the desired samplerate, and the stream timeout value\n specified via bladerf_set_stream_timeout(), which defaults to 1 second.\n\n For a given sample rate, the below relationship must be upheld to transmit or\n receive data without timeouts or dropped data.\n\n @f[\n Sample\\ Rate > \\frac{\\#\\ Transfers}{Timeout} \\times Buffer\\ Size\n @f]\n\n ...where Sample Rate is in samples per second, and Timeout is in seconds.\n\n To account for general system overhead, it is recommended to multiply the\n righthand side by 1.1 to 1.25.\n\n While increasing the number of buffers available provides additional\n elasticity, be aware that it also increases latency.\n\n @param[out]  stream          Upon success, this will be updated to contain\n                              a stream handle (i.e., address)\n @param       dev             Device to associate with the stream\n @param[in]   callback        Callback routine to handle asynchronous events\n @param[out]  buffers         This will be updated to point to a dynamically\n                              allocated array of buffer pointers.\n @param[in]   num_buffers     Number of buffers to allocate and return. This\n                              value must >= the `num_transfers` parameter.\n @param[in]   format          Sample data format\n @param[in]   samples_per_buffer  Size of allocated buffers, in units of\n                                  samples Note that the physical size of the\n                                  buffer is a function of this and the format\n                                  parameter.\n @param[in]   num_transfers   Maximum number of transfers that may be\n                              in-flight simultaneously. This must be <= the\n                              `num_buffers` parameter.\n @param[in]   user_data       Caller-provided data that will be provided\n                              in stream callbacks\n\n @note  This call should be later followed by a call to\n        bladerf_deinit_stream() to avoid memory leaks.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_init_stream(
        stream: *mut *mut bladerf_stream,
        dev: *mut bladerf,
        callback: bladerf_stream_cb,
        buffers: *mut *mut *mut ::libc::c_void,
        num_buffers: usize,
        format: bladerf_format,
        samples_per_buffer: usize,
        num_transfers: usize,
        user_data: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Begin running a stream. This call will block until the stream completes.\n\n Only 1 RX stream and 1 TX stream may be running at a time. Attempting to\n call bladerf_stream() with more than one stream will yield unexpected (and\n most likely undesirable) results.\n\n @note See the ::bladerf_stream_cb description for additional thread-safety\n       caveats.\n\n @pre This function should be preceded by a call to bladerf_enable_module()\n      to enable the associated RX or TX directions before attempting to use\n      it to stream data.\n\n @param      stream   A stream handle that has been successfully been\n                      initialized via bladerf_init_stream()\n @param[in]  layout   Stream direction and channel layout\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_stream(
        stream: *mut bladerf_stream,
        layout: bladerf_channel_layout,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Submit a buffer to a stream from outside of a stream callback function.\n Use this only when returning BLADERF_STREAM_NO_DATA from callbacks. <b>Do\n not</b> use this function if the associated callback functions will be\n returning buffers for submission.\n\n This call may block if the device is not ready to submit a buffer for\n transfer. Use the `timeout_ms` to place an upper limit on the time this\n function can block.\n\n To safely submit buffers from outside the stream callback flow, this function\n internally acquires a per-stream lock (the same one that is held during the\n execution of a stream callback). Therefore, it is important to be aware of\n locks that may be held while making this call, especially those acquired\n during execution of the associated stream callback function. (i.e., be wary\n of the order of lock acquisitions, including the internal per-stream lock.)\n\n @param           stream      Stream to submit buffer to\n @param[inout]    buffer      Buffer to fill (RX) or containing data (TX).\n                              This buffer is assumed to be the size specified\n                              in the associated bladerf_init_stream() call.\n @param[in]       timeout_ms  Milliseconds to timeout in, if this call blocks.\n                              0 implies an \"infinite\" wait.\n\n @return 0 on success, ::BLADERF_ERR_TIMEOUT upon a timeout, or a value from\n         \\ref RETCODES list on other failures"]
    pub fn bladerf_submit_stream_buffer(
        stream: *mut bladerf_stream,
        buffer: *mut ::libc::c_void,
        timeout_ms: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " This is a non-blocking variant of bladerf_submit_stream_buffer(). All of the\n caveats and important notes from bladerf_submit_stream_buffer() apply.\n\n In the event that this call would need to block in order to submit a buffer,\n it returns BLADERF_ERR_WOULD_BLOCK. In this case, the caller could either\n wait and try again or defer buffer submission to the asynchronous callback.\n\n @param           stream      Stream to submit buffer to\n @param[inout]    buffer      Buffer to fill (RX) or containing data (TX).\n                              This buffer is assumed to be the size specified\n                              in the associated bladerf_init_stream() call.\n\n @return  0 on success, ::BLADERF_ERR_WOULD_BLOCK if the call would have to\n          block to succeed, or another value from \\ref RETCODES upon other\n          failure"]
    pub fn bladerf_submit_stream_buffer_nb(
        stream: *mut bladerf_stream,
        buffer: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Deinitialize and deallocate stream resources.\n\n @pre  Stream is no longer being used (via bladerf_submit_stream_buffer() or\n       bladerf_stream() calls.)\n\n @post Stream is deallocated and may no longer be used.\n\n @param   stream  Stream to deinitialize. This function does nothing if\n                  stream is `NULL`."]
    pub fn bladerf_deinit_stream(stream: *mut bladerf_stream);
}
extern "C" {
    #[doc = " Set stream transfer timeout in milliseconds\n\n @param       dev         Device handle\n @param[in]   dir         Stream direction\n @param[in]   timeout     Timeout in milliseconds\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_stream_timeout(
        dev: *mut bladerf,
        dir: bladerf_direction,
        timeout: ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get transfer timeout in milliseconds\n\n @param       dev         Device handle\n @param[in]   dir         Stream direction\n @param[out]  timeout     On success, updated with current transfer\n                          timeout value. Undefined on failure.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_stream_timeout(
        dev: *mut bladerf,
        dir: bladerf_direction,
        timeout: *mut ::libc::c_uint,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write FX3 firmware to the bladeRF's SPI flash\n\n @note This will require a power cycle to take effect\n\n @param       dev         Device handle\n @param[in]   firmware    Full path to firmware file\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_flash_firmware(
        dev: *mut bladerf,
        firmware: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Load device's FPGA.\n\n @note This FPGA configuration will be reset at the next power cycle.\n\n @param       dev         Device handle\n @param[in]   fpga        Full path to FPGA bitstream\n\n @return 0 upon successfully, or a value from \\ref RETCODES list on failure"]
    pub fn bladerf_load_fpga(dev: *mut bladerf, fpga: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write the provided FPGA image to the bladeRF's SPI flash and enable FPGA\n loading from SPI flash at power on (also referred to within this project as\n FPGA \"autoloading\").\n\n @param       dev         Device handle\n @param[in]   fpga_image  Full path to FPGA file\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_flash_fpga(
        dev: *mut bladerf,
        fpga_image: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Erase the FPGA region of SPI flash, effectively disabling FPGA autoloading\n\n @param   dev         Device handle\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_erase_stored_fpga(dev: *mut bladerf) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Reset the device, causing it to reload its firmware from flash\n\n @param   dev         Device handle\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_device_reset(dev: *mut bladerf) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read firmware log data and write it to the specified file\n\n @param       dev         Device to read firmware log from\n @param[in]   filename    Filename to write log information to. If set to\n                          `NULL`, log data will be printed to stdout.\n\n @return 0 upon success, or a value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_fw_log(dev: *mut bladerf, filename: *const ::libc::c_char) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Clear out a firmware signature word in flash and jump to FX3 bootloader.\n\n The device will continue to boot into the FX3 bootloader across power cycles\n until new firmware is written to the device.\n\n @param   dev         Device handle\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_jump_to_bootloader(dev: *mut bladerf) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get a list of devices that are running the FX3 bootloader.\n\n After obtaining this list, identify the device that you would like to load\n firmware onto. Save the bus and address values so that you can provide them\n to bladerf_load_fw_from_bootloader(), and then free this list via\n bladerf_free_device_list().\n\n @param[out]   list    Upon finding devices, this will be updated to point\n                       to a list of bladerf_devinfo structures that\n                       describe the identified devices.\n\n @return Number of items populated in `list`,\n         or an error value from the \\ref RETCODES list on failure"]
    pub fn bladerf_get_bootloader_list(list: *mut *mut bladerf_devinfo) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Download firmware to the specified device that is enumarating an FX3\n bootloader, and begin executing the firmware from RAM.\n\n @note This function <b>does not</b> write the firmware to SPI flash. If this\n is desired, open the newly enumerated device with bladerf_open() and use\n bladerf_flash_firmware().\n\n @param[in]   device_identifier   Device identifier string describing the\n                                  backend to use via the\n                                  `<backend>:device=<bus>:<addr>` syntax.  If\n                                  this is NULL, the backend, bus, and addr\n                                  arguments will be used instead.\n @param[in]   backend             Backend to use. This is only used if\n                                  device_identifier is `NULL`.\n @param[in]   bus                 Bus number the device is located on. This\n                                  is only used if device_identifier is `NULL`.\n @param[in]   addr                Bus address the device is located on. This\n                                  is only used if device_identifier is `NULL`.\n @param[in]   file                Filename of the firmware image to boot\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_load_fw_from_bootloader(
        device_identifier: *const ::libc::c_char,
        backend: bladerf_backend,
        bus: u8,
        addr: u8,
        file: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
#[doc = "< Used to denote invalid value"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_INVALID: bladerf_image_type = -1;
#[doc = "< Misc. raw data"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_RAW: bladerf_image_type = 0;
#[doc = "< Firmware data"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_FIRMWARE: bladerf_image_type = 1;
#[doc = "< FPGA bitstream for 40 KLE device"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_FPGA_40KLE: bladerf_image_type = 2;
#[doc = "< FPGA bitstream for 115  KLE device"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_FPGA_115KLE: bladerf_image_type = 3;
#[doc = "< FPGA bitstream for A4 device"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_FPGA_A4: bladerf_image_type = 4;
#[doc = "< FPGA bitstream for A9 device"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_FPGA_A9: bladerf_image_type = 5;
#[doc = "< Board calibration"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_CALIBRATION: bladerf_image_type = 6;
#[doc = "< RX DC offset calibration table"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_RX_DC_CAL: bladerf_image_type = 7;
#[doc = "< TX DC offset calibration table"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_TX_DC_CAL: bladerf_image_type = 8;
#[doc = "< RX IQ balance calibration table"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_RX_IQ_CAL: bladerf_image_type = 9;
#[doc = "< TX IQ balance calibration table"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_TX_IQ_CAL: bladerf_image_type = 10;
#[doc = "< FPGA bitstream for A5 device"]
pub const bladerf_image_type_BLADERF_IMAGE_TYPE_FPGA_A5: bladerf_image_type = 11;
#[doc = " Type of data stored in a flash image"]
pub type bladerf_image_type = ::libc::c_int;
#[doc = " Image format for backing up and restoring bladeRF flash contents\n\n The on disk format generated by the bladerf_image_write function is a\n serialized version of this structure and its contents. When written to disk,\n values are converted to big-endian byte order, for ease of reading in a hex\n editor.\n\n When creating and using a bladerf_image of type ::BLADERF_IMAGE_TYPE_RAW,\n the address and length fields must be erase-block aligned."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_image {
    #[doc = " Magic value used to identify image file format.\n\n Note that an extra character is added to store a `NUL`-terminator,\n to allow this field to be printed. This `NUL`-terminator is *NOT*\n written in the serialized image."]
    pub magic: [::libc::c_char; 8usize],
    #[doc = " SHA256 checksum of the flash image. This is computed over the entire\n image, with this field filled with 0's."]
    pub checksum: [u8; 32usize],
    #[doc = " Image format version. Only the major, minor, and patch fields are\n written to the disk; the describe field is not used. The version is\n serialized as: [major | minor | patch]"]
    pub version: bladerf_version,
    #[doc = " UTC image timestamp, in seconds since the Unix Epoch"]
    pub timestamp: u64,
    #[doc = " Serial number of the device that the image was obtained from. This\n field should be all '\\0' if irrelevant.\n\n The +1 here is actually extraneous; ::BLADERF_SERIAL_LENGTH already\n accounts for a `NUL` terminator. However, this is left here to avoid\n breaking backwards compatibility."]
    pub serial: [::libc::c_char; 34usize],
    #[doc = " Reserved for future metadata. Should be 0's."]
    pub reserved: [::libc::c_char; 128usize],
    #[doc = " Type of data contained in the image. Serialized as a uint32_t."]
    pub type_: bladerf_image_type,
    #[doc = " Address of the flash data in this image. A value of `0xffffffff`\n implies that this field is left unspecified (i.e., \"don't care\")."]
    pub address: u32,
    #[doc = " Length of the data contained in the image"]
    pub length: u32,
    #[doc = " Image data"]
    pub data: *mut u8,
}
#[test]
fn bindgen_test_layout_bladerf_image() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_image> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_image>(),
        248usize,
        concat!("Size of: ", stringify!(bladerf_image))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_image>(),
        8usize,
        concat!("Alignment of ", stringify!(bladerf_image))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).magic) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_image),
            "::",
            stringify!(magic)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).checksum) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_image),
            "::",
            stringify!(checksum)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_image),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).timestamp) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_image),
            "::",
            stringify!(timestamp)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).serial) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_image),
            "::",
            stringify!(serial)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        98usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_image),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).type_) as usize - ptr as usize },
        228usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_image),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).address) as usize - ptr as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_image),
            "::",
            stringify!(address)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).length) as usize - ptr as usize },
        236usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_image),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_image),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    #[doc = " Allocate and initialize an image structure.\n\n This following bladerf_image fields are populated: `magic`, `version`,\n `timestamp`, `type`, `address`, and `length`\n\n The following bladerf_image fields are zeroed out: `checksum`, `serial`, and\n `reserved`\n\n If the `length` parameter is not 0, the ::bladerf_image `data` field will be\n dynamically allocated. Otherwise, `data` will be set to NULL.\n\n @note A non-zero `length` should be use only with bladerf_image_write();\n       bladerf_image_read() allocates and sets `data` based upon size of the\n       image contents, and does not attempt to free() the `data` field before\n       setting it.\n\n The `address` and `length` fields should be set 0 when reading an image from\n a file.\n\n @return Pointer to allocated and initialized structure on success,\n         `NULL` on memory allocation failure or invalid address/length."]
    pub fn bladerf_alloc_image(
        dev: *mut bladerf,
        type_: bladerf_image_type,
        address: u32,
        length: u32,
    ) -> *mut bladerf_image;
}
extern "C" {
    #[doc = " Create a flash image initialized to contain a calibration data region.\n\n This is intended to be used in conjunction with bladerf_image_write(), or a\n write of the image's `data` field to flash.\n\n @param[in]   dev          Device handle\n @param[in]   fpga_size    Target FPGA size\n @param[in]   vctcxo_trim  VCTCXO oscillator trim value.\n\n @return Pointer to allocated and initialized structure on success,\n         `NULL` on memory allocation failure"]
    pub fn bladerf_alloc_cal_image(
        dev: *mut bladerf,
        fpga_size: bladerf_fpga_size,
        vctcxo_trim: u16,
    ) -> *mut bladerf_image;
}
extern "C" {
    #[doc = " Free a bladerf_image previously obtained via bladerf_alloc_image.\n\n If the bladerf_image's `data` field is non-`NULL`, it will be freed.\n\n @param[inout]    image   Flash image"]
    pub fn bladerf_free_image(image: *mut bladerf_image);
}
extern "C" {
    #[doc = " Write a flash image to a file.\n\n This function will fill in the checksum field before writing the contents to\n the specified file. The user-supplied contents of this field are ignored.\n\n @pre  `image` has been initialized using bladerf_alloc_image()\n @post `image->checksum` will be populated if this function succeeds\n\n @param[in]    dev         Device handle\n @param[in]    image       Flash image\n @param[in]    file        File to write the flash image to\n\n @return 0 upon success, or a value from \\ref RETCODES list on failure"]
    pub fn bladerf_image_write(
        dev: *mut bladerf,
        image: *mut bladerf_image,
        file: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read flash image from a file.\n\n @pre  The `image` parameter has been obtained via a call to\n       bladerf_alloc_image(), with a `length` of 0.\n\n @post The `image` fields will be populated upon success, overwriting any\n       previous values.\n\n @note The contents of the `image` parameter should not be used if this\n       function fails.\n\n @param[out]   image      Flash image structure to populate.\n @param[in]    file       File to read image from.\n\n @return 0 upon success,\n         ::BLADERF_ERR_CHECKSUM upon detecting a checksum mismatch,\n         ::BLADERF_ERR_INVAL if any image fields are invalid,\n         ::BLADERF_ERR_IO on a file I/O error,\n         or a value from \\ref RETCODES list on any other failure"]
    pub fn bladerf_image_read(
        image: *mut bladerf_image,
        file: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
#[doc = " Denotes an invalid selection or state"]
pub const bladerf_vctcxo_tamer_mode_BLADERF_VCTCXO_TAMER_INVALID: bladerf_vctcxo_tamer_mode = -1;
#[doc = " Do not attempt to tame the VCTCXO with an input source."]
pub const bladerf_vctcxo_tamer_mode_BLADERF_VCTCXO_TAMER_DISABLED: bladerf_vctcxo_tamer_mode = 0;
#[doc = " Use a 1 pps input source to tame the VCTCXO."]
pub const bladerf_vctcxo_tamer_mode_BLADERF_VCTCXO_TAMER_1_PPS: bladerf_vctcxo_tamer_mode = 1;
#[doc = " Use a 10 MHz input source to tame the VCTCXO."]
pub const bladerf_vctcxo_tamer_mode_BLADERF_VCTCXO_TAMER_10_MHZ: bladerf_vctcxo_tamer_mode = 2;
#[doc = " VCTCXO Tamer mode selection\n\n These values control the use of header J71 pin 1 for taming the\n on-board VCTCXO to improve or sustain frequency accuracy.\n\n When supplying input into the VCTCXO tamer, a 1.8V signal must be provided.\n\n @warning IMPORTANT: Exceeding 1.8V on J71-1 can damage the associated FPGA\n          I/O bank. Ensure that you provide only a 1.8V signal!"]
pub type bladerf_vctcxo_tamer_mode = ::libc::c_int;
extern "C" {
    #[doc = " Set the VCTCXO tamer mode.\n\n @param       dev         Device handle\n @param[in]   mode        VCTCXO taming mode\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_vctcxo_tamer_mode(
        dev: *mut bladerf,
        mode: bladerf_vctcxo_tamer_mode,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the current VCTCXO tamer mode\n\n @param           dev         Device handle\n @param[out]      mode        Current VCTCXO taming mode or\n                              ::BLADERF_VCTCXO_TAMER_INVALID if a failure\n                              occurs.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_vctcxo_tamer_mode(
        dev: *mut bladerf,
        mode: *mut bladerf_vctcxo_tamer_mode,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Query a device's VCTCXO calibration trim\n\n @param       dev     Device handle\n @param[out]  trim    VCTCXO calibration trim\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_vctcxo_trim(dev: *mut bladerf, trim: *mut u16) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write value to VCTCXO trim DAC.\n\n @note This should not be used when the VCTCXO tamer is enabled.\n\n @param       dev     Device handle\n @param[in]   val     Desired VCTCXO trim DAC value\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_trim_dac_write(dev: *mut bladerf, val: u16) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read value from VCTCXO trim DAC.\n\n This is similar to bladerf_get_vctcxo_trim(), except that it returns the\n current trim DAC value, as opposed to the calibration value read from flash.\n\n Use this if you are trying to query the value after having previously made\n calls to bladerf_trim_dac_write().\n\n @param       dev     Device handle\n @param[out]  val     Current VCTCXO trim DAC value\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_trim_dac_read(dev: *mut bladerf, val: *mut u16) -> ::libc::c_int;
}
#[doc = " Indicates an invalid mode is set"]
pub const bladerf_tuning_mode_BLADERF_TUNING_MODE_INVALID: bladerf_tuning_mode = -1;
#[doc = " Perform tuning algorithm on the host. This is slower, but provides\n easier accessiblity to diagnostic information."]
pub const bladerf_tuning_mode_BLADERF_TUNING_MODE_HOST: bladerf_tuning_mode = 0;
#[doc = " Perform tuning algorithm on the FPGA for faster tuning."]
pub const bladerf_tuning_mode_BLADERF_TUNING_MODE_FPGA: bladerf_tuning_mode = 1;
#[doc = " Frequency tuning modes\n\n ::BLADERF_TUNING_MODE_HOST is the default if either of the following\n conditions are true:\n   - libbladeRF < v1.3.0\n   - FPGA       < v0.2.0\n\n ::BLADERF_TUNING_MODE_FPGA is the default if both of the following\n conditions are true:\n  - libbladeRF >= v1.3.0\n  - FPGA       >= v0.2.0\n\n The default mode can be overridden by setting a BLADERF_DEFAULT_TUNING_MODE\n environment variable to `host` or `fpga`.\n\n @note Overriding this value with a mode not supported by the FPGA will result\n       in failures or unexpected behavior."]
pub type bladerf_tuning_mode = ::libc::c_int;
extern "C" {
    #[doc = " Set the device's tuning mode\n\n @param       dev         Device handle\n @param[in]   mode        Desired tuning mode. Note that the available modes\n                          depends on the FPGA version.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_tuning_mode(dev: *mut bladerf, mode: bladerf_tuning_mode) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the device's current tuning mode\n\n @param       dev         Device handle\n @param[in]   mode        Tuning mode\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_tuning_mode(
        dev: *mut bladerf,
        mode: *mut bladerf_tuning_mode,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read trigger control register\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   signal      Trigger signal (control register) to read from\n @param[out]  val         Pointer to variable that register is read into See\n                          the BLADERF_TRIGGER_REG_* macros for the meaning of\n                          each bit.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_read_trigger(
        dev: *mut bladerf,
        ch: bladerf_channel,
        signal: bladerf_trigger_signal,
        val: *mut u8,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write trigger control register\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   signal      Trigger signal to configure\n @param[in]   val         Data to write into the trigger control register.\n                          See the BLADERF_TRIGGER_REG_* macros for options.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_write_trigger(
        dev: *mut bladerf,
        ch: bladerf_channel,
        signal: bladerf_trigger_signal,
        val: u8,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read a specific Wishbone Master address\n\n @param       dev     Device handle\n @param       addr    Wishbone Master address\n @param[out]  data    Wishbone Master data\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_wishbone_master_read(
        dev: *mut bladerf,
        addr: u32,
        data: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write value to a specific Wishbone Master address\n\n\n @param       dev     Device handle\n @param       addr    Wishbone Master address\n @param       data    Wishbone Master data\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_wishbone_master_write(dev: *mut bladerf, addr: u32, val: u32) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read the configuration GPIO register.\n\n @param       dev     Device handle\n @param[out]  val     Current configuration GPIO value\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_config_gpio_read(dev: *mut bladerf, val: *mut u32) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write the configuration GPIO register.\n\n @note Callers should be sure to perform a read-modify-write sequence to\n       avoid accidentally clearing other GPIO bits that may be set by the\n       library internally.\n\n @param       dev     Device handle\n @param[out]  val     Desired configuration GPIO value\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_config_gpio_write(dev: *mut bladerf, val: u32) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Erase regions of the bladeRF's SPI flash\n\n @note This function operates in units of 64 KiB erase blocks\n @note Not recommended for new designs. Consider using the\n       `bladerf_erase_flash_bytes()` function instead. It will perform the\n       necessary conversion from bytes to pages based on the specific\n       flash architecture found on the board.\n\n @param       dev             Device handle\n @param[in]   erase_block     Erase block from which to start erasing\n @param[in]   count           Number of blocks to erase\n\n @return 0 on success,\n         or ::BLADERF_ERR_INVAL on an invalid `erase_block` or `count` value,\n         or a value from \\ref RETCODES list on other failures"]
    pub fn bladerf_erase_flash(dev: *mut bladerf, erase_block: u32, count: u32) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Erase regions of the bladeRF's SPI flash\n\n @note This function operates in units of bytes\n\n @param       dev             Device handle\n @param[in]   address         Address at which to start erasing\n @param[in]   length          Number of bytes to erase\n\n @return 0 on success,\n         or ::BLADERF_ERR_INVAL on an invalid `address` or `length` value,\n         or a value from \\ref RETCODES list on other failures"]
    pub fn bladerf_erase_flash_bytes(dev: *mut bladerf, address: u32, length: u32)
        -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read data from the bladeRF's SPI flash\n\n @note This function operates in units of flash pages.\n @note Not recommended for new designs. Consider using the\n       `bladerf_read_flash_bytes()` function instead. It will perform the\n       necessary conversion from bytes to pages based on the specific\n       flash architecture found on the board.\n\n @param       dev     Device handle\n @param[in]   buf     Buffer to read data into. Must be `count` *\n                      flash-page-size bytes or larger.\n @param[in]   page    Page to begin reading from\n @param[in]   count   Number of pages to read\n\n @return 0 on success,\n         or ::BLADERF_ERR_INVAL on an invalid `page` or `count` value,\n         or a value from \\ref RETCODES list on other failures."]
    pub fn bladerf_read_flash(
        dev: *mut bladerf,
        buf: *mut u8,
        page: u32,
        count: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read data from the bladeRF's SPI flash\n\n @note This function operates in units of bytes.\n\n @param       dev     Device handle\n @param[in]   buf     Buffer to read data into. Must be `bytes`\n                      bytes or larger.\n @param[in]   address Address to begin reading from\n @param[in]   bytes   Number of bytes to read\n\n @return 0 on success,\n         or ::BLADERF_ERR_INVAL on an invalid `address` or `bytes` value,\n         or a value from \\ref RETCODES list on other failures."]
    pub fn bladerf_read_flash_bytes(
        dev: *mut bladerf,
        buf: *mut u8,
        address: u32,
        bytes: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write data to the bladeRF's SPI flash device\n\n @note This function operates in units of flash pages.\n @note Not recommended for new designs. Consider using the\n       `bladerf_write_flash_bytes()` function instead. It will perform the\n       necessary conversion from bytes to pages based on the specific\n       flash architecture found on the board.\n\n @param       dev     Device handle\n @param[in]   buf     Data to write to flash\n @param[in]   page    Page to begin writing at\n @param[in]   count   Number of pages to write\n\n @return 0 on success,\n         or ::BLADERF_ERR_INVAL on an invalid `page` or `count` value,\n         or a value from \\ref RETCODES list on other failures."]
    pub fn bladerf_write_flash(
        dev: *mut bladerf,
        buf: *const u8,
        page: u32,
        count: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write data to the bladeRF's SPI flash device\n\n @note This function operates in units of bytes.\n\n @param       dev     Device handle\n @param[in]   buf     Data to write to flash\n @param[in]   address Address to begin writing at\n @param[in]   length  Number of bytes to write\n\n @return 0 on success,\n         or ::BLADERF_ERR_INVAL on an invalid `address` or `length` value,\n         or a value from \\ref RETCODES list on other failures."]
    pub fn bladerf_write_flash_bytes(
        dev: *mut bladerf,
        buf: *const u8,
        address: u32,
        length: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Lock the bladeRF's OTP\n\n @param       dev     Device handle\n\n @return 0 on success,\n         or ::BLADERF_ERR_INVAL on an invalid `page` or `count` value,\n         or a value from \\ref RETCODES list on other failures."]
    pub fn bladerf_lock_otp(dev: *mut bladerf) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read data from the bladeRF's SPI flash OTP\n\n @note This function operates solely on the first 256 byte page of the OTP\n\n @param       dev     Device handle\n @param[in]   buf     Buffer to read OTP data into\n\n @return 0 on success,\n         or ::BLADERF_ERR_INVAL on an invalid `page` or `count` value,\n         or a value from \\ref RETCODES list on other failures."]
    pub fn bladerf_read_otp(dev: *mut bladerf, buf: *mut u8) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write data to the bladeRF's SPI flash OTP device\n\n @note This function operates solely on the first 256 byte page of the OTP\n\n @param       dev     Device handle\n @param[in]   buf     Data to write to OTP\n\n @return 0 on success,\n         or ::BLADERF_ERR_INVAL on an invalid `page` or `count` value,\n         or a value from \\ref RETCODES list on other failures."]
    pub fn bladerf_write_otp(dev: *mut bladerf, buf: *mut u8) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the RF port\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   port        RF port name\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_rf_port(
        dev: *mut bladerf,
        ch: bladerf_channel,
        port: *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the RF port\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  port        RF port name\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_rf_port(
        dev: *mut bladerf,
        ch: bladerf_channel,
        port: *mut *const ::libc::c_char,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get available RF ports\n\n This function may be called with `NULL` for `ports`, or 0 for `count`, to\n determine the number of RF ports.\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  ports       RF port names\n @param[out]  count       Number to populate\n\n @return Number of RF ports on success, value from \\ref RETCODES list on\n         failure"]
    pub fn bladerf_get_rf_ports(
        dev: *mut bladerf,
        ch: bladerf_channel,
        ports: *mut *const ::libc::c_char,
        count: ::libc::c_uint,
    ) -> ::libc::c_int;
}
#[doc = "< No feature enabled"]
pub const bladerf_feature_BLADERF_FEATURE_DEFAULT: bladerf_feature = 0;
#[doc = "< Enforces AD9361 OC and 8bit mode"]
pub const bladerf_feature_BLADERF_FEATURE_OVERSAMPLE: bladerf_feature = 1;
#[doc = " Feature Set"]
pub type bladerf_feature = ::libc::c_uint;
extern "C" {
    #[doc = " Enables a feature.\n\n @param       dev         Device handle\n @param[out]  feature     Feature\n @param[in]   enable  true to enable, false to disable\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_enable_feature(
        dev: *mut bladerf,
        feature: bladerf_feature,
        enable: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Gets currently enabled feature.\n\n @param       dev         Device handle\n @param[out]  feature     Feature\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_feature(dev: *mut bladerf, feature: *mut bladerf_feature) -> ::libc::c_int;
}
#[doc = "< No expansion boards attached"]
pub const bladerf_xb_BLADERF_XB_NONE: bladerf_xb = 0;
#[doc = "< XB-100 GPIO expansion board.\n   This device is not yet supported in\n   libbladeRF, and is here as a placeholder\n   for future support."]
pub const bladerf_xb_BLADERF_XB_100: bladerf_xb = 1;
#[doc = "< XB-200 Transverter board"]
pub const bladerf_xb_BLADERF_XB_200: bladerf_xb = 2;
#[doc = "< XB-300 Amplifier board"]
pub const bladerf_xb_BLADERF_XB_300: bladerf_xb = 3;
#[doc = " Expansion boards"]
pub type bladerf_xb = ::libc::c_uint;
extern "C" {
    #[doc = " Attach and enable an expansion board's features\n\n @param       dev         Device handle\n @param[in]   xb          Expansion board\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_expansion_attach(dev: *mut bladerf, xb: bladerf_xb) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Determine which expansion board is attached\n\n @param       dev         Device handle\n @param[out]  xb          Expansion board\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_expansion_get_attached(dev: *mut bladerf, xb: *mut bladerf_xb) -> ::libc::c_int;
}
#[doc = "< Verbose level logging"]
pub const bladerf_log_level_BLADERF_LOG_LEVEL_VERBOSE: bladerf_log_level = 0;
#[doc = "< Debug level logging"]
pub const bladerf_log_level_BLADERF_LOG_LEVEL_DEBUG: bladerf_log_level = 1;
#[doc = "< Information level logging"]
pub const bladerf_log_level_BLADERF_LOG_LEVEL_INFO: bladerf_log_level = 2;
#[doc = "< Warning level logging"]
pub const bladerf_log_level_BLADERF_LOG_LEVEL_WARNING: bladerf_log_level = 3;
#[doc = "< Error level logging"]
pub const bladerf_log_level_BLADERF_LOG_LEVEL_ERROR: bladerf_log_level = 4;
#[doc = "< Fatal error level logging"]
pub const bladerf_log_level_BLADERF_LOG_LEVEL_CRITICAL: bladerf_log_level = 5;
#[doc = "< No output"]
pub const bladerf_log_level_BLADERF_LOG_LEVEL_SILENT: bladerf_log_level = 6;
#[doc = " Severity levels for logging functions"]
pub type bladerf_log_level = ::libc::c_uint;
extern "C" {
    #[doc = " Sets the filter level for displayed log messages.\n\n Messages that are at or above the specified log level will be printed, while\n messages with a lower log level will be suppressed.\n\n @param[in]   level       The new log level filter value"]
    pub fn bladerf_log_set_verbosity(level: bladerf_log_level);
}
extern "C" {
    #[doc = " Get libbladeRF version information\n\n @param[out]  version     libbladeRF version information"]
    pub fn bladerf_version(version: *mut bladerf_version);
}
extern "C" {
    #[doc = " Obtain a textual description of a value from the \\ref RETCODES list\n\n @param[in]   error   Error value to look up\n\n @return  Error string"]
    pub fn bladerf_strerror(error: ::libc::c_int) -> *const ::libc::c_char;
}
#[doc = "< Invalid LNA gain"]
pub const bladerf_lna_gain_BLADERF_LNA_GAIN_UNKNOWN: bladerf_lna_gain = 0;
#[doc = "< LNA bypassed - 0dB gain"]
pub const bladerf_lna_gain_BLADERF_LNA_GAIN_BYPASS: bladerf_lna_gain = 1;
#[doc = "< LNA Mid Gain (MAX-6dB)"]
pub const bladerf_lna_gain_BLADERF_LNA_GAIN_MID: bladerf_lna_gain = 2;
#[doc = "< LNA Max Gain"]
pub const bladerf_lna_gain_BLADERF_LNA_GAIN_MAX: bladerf_lna_gain = 3;
#[doc = " LNA gain options\n\n \\deprecated Use bladerf_get_gain_stage_range()"]
pub type bladerf_lna_gain = ::libc::c_uint;
extern "C" {
    #[doc = " Set the PA gain in dB\n\n \\deprecated Use either bladerf_set_gain() or bladerf_set_gain_stage().\n\n Values outside the range of\n [ \\ref BLADERF_TXVGA2_GAIN_MIN, \\ref BLADERF_TXVGA2_GAIN_MAX ]\n will be clamped.\n\n @param       dev         Device handle\n @param[in]   gain        Desired gain\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_txvga2(dev: *mut bladerf, gain: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the PA gain in dB\n\n \\deprecated Use either bladerf_get_gain() or bladerf_get_gain_stage().\n\n @param       dev         Device handle\n @param[out]  gain        Pointer to returned gain\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_txvga2(dev: *mut bladerf, gain: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the post-LPF gain in dB\n\n \\deprecated Use either bladerf_set_gain() or bladerf_set_gain_stage().\n\n Values outside the range of\n [ \\ref BLADERF_TXVGA1_GAIN_MIN, \\ref BLADERF_TXVGA1_GAIN_MAX ]\n will be clamped.\n\n @param       dev         Device handle\n @param[in]   gain        Desired gain\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_txvga1(dev: *mut bladerf, gain: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the post-LPF gain in dB\n\n \\deprecated Use either bladerf_get_gain() or bladerf_get_gain_stage().\n\n @param       dev         Device handle\n @param[out]  gain        Pointer to returned gain\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_txvga1(dev: *mut bladerf, gain: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the LNA gain\n\n \\deprecated Use either bladerf_set_gain() or bladerf_set_gain_stage().\n\n @param       dev         Device handle\n @param[in]   gain        Desired gain level\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_lna_gain(dev: *mut bladerf, gain: bladerf_lna_gain) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the LNA gain\n\n \\deprecated Use either bladerf_get_gain() or bladerf_get_gain_stage().\n\n @param       dev         Device handle\n @param[out]  gain        Pointer to the set gain level\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_lna_gain(dev: *mut bladerf, gain: *mut bladerf_lna_gain) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the pre-LPF VGA gain\n\n \\deprecated Use either bladerf_set_gain() or bladerf_set_gain_stage().\n\n Values outside the range of\n [ \\ref BLADERF_RXVGA1_GAIN_MIN, \\ref BLADERF_RXVGA1_GAIN_MAX ]\n will be clamped.\n\n @param       dev         Device handle\n @param[in]   gain        Desired gain\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_rxvga1(dev: *mut bladerf, gain: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the pre-LPF VGA gain\n\n \\deprecated Use either bladerf_get_gain() or bladerf_get_gain_stage().\n\n @param       dev         Device handle\n @param[out]  gain        Pointer to the set gain level\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_rxvga1(dev: *mut bladerf, gain: *mut ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the post-LPF VGA gain\n\n \\deprecated Use either bladerf_set_gain() or bladerf_set_gain_stage().\n\n Values outside the range of\n [ \\ref BLADERF_RXVGA2_GAIN_MIN, \\ref BLADERF_RXVGA2_GAIN_MAX ]\n will be clamped.\n\n @param       dev         Device handle\n @param[in]   gain        Desired gain\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_rxvga2(dev: *mut bladerf, gain: ::libc::c_int) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the post-LPF VGA gain\n\n \\deprecated Use either bladerf_get_gain() or bladerf_get_gain_stage().\n\n @param       dev         Device handle\n @param[out]  gain        Pointer to the set gain level"]
    pub fn bladerf_get_rxvga2(dev: *mut bladerf, gain: *mut ::libc::c_int) -> ::libc::c_int;
}
#[doc = "< Unable to determine connection type"]
pub const bladerf_sampling_BLADERF_SAMPLING_UNKNOWN: bladerf_sampling = 0;
#[doc = "< Sample from RX/TX connector"]
pub const bladerf_sampling_BLADERF_SAMPLING_INTERNAL: bladerf_sampling = 1;
#[doc = "< Sample from J60 or J61"]
pub const bladerf_sampling_BLADERF_SAMPLING_EXTERNAL: bladerf_sampling = 2;
#[doc = " Sampling connection"]
pub type bladerf_sampling = ::libc::c_uint;
extern "C" {
    #[doc = " Configure the sampling of the LMS6002D to be either internal or external.\n\n Internal sampling will read from the RXVGA2 driver internal to the chip.\n External sampling will connect the ADC inputs to the external inputs for\n direct sampling.\n\n @param       dev         Device handle\n @param[in]   sampling    Sampling connection\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_sampling(dev: *mut bladerf, sampling: bladerf_sampling) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read the device's current state of RXVGA2 and ADC pin connection\n to figure out which sampling mode it is currently configured in.\n\n @param       dev         Device handle\n @param[out]  sampling    Sampling connection\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_sampling(
        dev: *mut bladerf,
        sampling: *mut bladerf_sampling,
    ) -> ::libc::c_int;
}
#[doc = "< LPF connected and enabled"]
pub const bladerf_lpf_mode_BLADERF_LPF_NORMAL: bladerf_lpf_mode = 0;
#[doc = "< LPF bypassed"]
pub const bladerf_lpf_mode_BLADERF_LPF_BYPASSED: bladerf_lpf_mode = 1;
#[doc = "< LPF disabled"]
pub const bladerf_lpf_mode_BLADERF_LPF_DISABLED: bladerf_lpf_mode = 2;
#[doc = " Low-Pass Filter (LPF) mode"]
pub type bladerf_lpf_mode = ::libc::c_uint;
extern "C" {
    #[doc = " Set the LMS LPF mode to bypass or disable it\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   mode        Mode to be set\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_lpf_mode(
        dev: *mut bladerf,
        ch: bladerf_channel,
        mode: bladerf_lpf_mode,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the current mode of the LMS LPF\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  mode        Current mode of the LPF\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_lpf_mode(
        dev: *mut bladerf,
        ch: bladerf_channel,
        mode: *mut bladerf_lpf_mode,
    ) -> ::libc::c_int;
}
#[doc = "< Invalid selection"]
pub const bladerf_smb_mode_BLADERF_SMB_MODE_INVALID: bladerf_smb_mode = -1;
#[doc = "< Not in use. Device operates from its onboard\n clock and does not use J62."]
pub const bladerf_smb_mode_BLADERF_SMB_MODE_DISABLED: bladerf_smb_mode = 0;
#[doc = "< Device outputs a 38.4 MHz reference clock on\n J62. This may be used to drive another device\n that is configured with\n ::BLADERF_SMB_MODE_INPUT."]
pub const bladerf_smb_mode_BLADERF_SMB_MODE_OUTPUT: bladerf_smb_mode = 1;
#[doc = "< Device configures J62 as an input and expects a\n 38.4 MHz reference to be available when this\n setting is applied."]
pub const bladerf_smb_mode_BLADERF_SMB_MODE_INPUT: bladerf_smb_mode = 2;
#[doc = "< SMB port is unavailable for use due to the\n underlying clock being used elsewhere (e.g.,\n for an expansion board)."]
pub const bladerf_smb_mode_BLADERF_SMB_MODE_UNAVAILBLE: bladerf_smb_mode = 3;
#[doc = " SMB clock port mode of operation"]
pub type bladerf_smb_mode = ::libc::c_int;
extern "C" {
    #[doc = " Set the current mode of operation of the SMB clock port\n\n In a MIMO configuration, one \"master\" device should first be configured to\n output its reference clock to the slave devices via\n `bladerf_set_smb_mode(dev, BLADERF_SMB_MODE_OUTPUT)`.\n\n Next, all \"slave\" devices should be configured to use the reference clock\n provided on the SMB clock port (instead of using their on-board reference)\n via `bladerf_set_smb_mode(dev, BLADERF_SMB_MODE_INPUT)`.\n\n @param       dev         Device handle\n @param[in]   mode        Desired mode\n\n @return 0 on success, or a value from \\ref RETCODES list on failure."]
    pub fn bladerf_set_smb_mode(dev: *mut bladerf, mode: bladerf_smb_mode) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the current mode of operation of the SMB clock port\n\n @param       dev         Device handle\n @param[out]  mode        Desired mode\n\n @return 0 on success, or a value from \\ref RETCODES list on failure."]
    pub fn bladerf_get_smb_mode(dev: *mut bladerf, mode: *mut bladerf_smb_mode) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the SMB clock port frequency in rational Hz\n\n @param       dev         Device handle\n @param[in]   rate        Rational frequency\n @param[out]  actual      If non-NULL, this is written with the actual\n\n The frequency must be between \\ref BLADERF_SMB_FREQUENCY_MIN and\n \\ref BLADERF_SMB_FREQUENCY_MAX.\n\n This function inherently configures the SMB clock port as an output. Do not\n call bladerf_set_smb_mode() with ::BLADERF_SMB_MODE_OUTPUT, as this will\n reset the output frequency to the 38.4 MHz reference.\n\n @warning This clock should not be set if an expansion board is connected.\n\n @return 0 on success,\n         BLADERF_ERR_INVAL for an invalid frequency,\n         or a value from \\ref RETCODES list on failure."]
    pub fn bladerf_set_rational_smb_frequency(
        dev: *mut bladerf,
        rate: *mut bladerf_rational_rate,
        actual: *mut bladerf_rational_rate,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the SMB connector output frequency in Hz.\n Use bladerf_set_rational_smb_frequency() for more arbitrary values.\n\n @param       dev         Device handle\n @param[in]   rate        Frequency\n @param[out]  actual      If non-NULL. this is written with the actual\n                          frequency achieved.\n\n This function inherently configures the SMB clock port as an output. Do not\n call bladerf_set_smb_mode() with ::BLADERF_SMB_MODE_OUTPUT, as this will\n reset the output frequency to the 38.4 MHz reference.\n\n The frequency must be between \\ref BLADERF_SMB_FREQUENCY_MIN and\n \\ref BLADERF_SMB_FREQUENCY_MAX.\n\n @warning This clock should not be set if an expansion board is connected.\n\n @return 0 on success,\n         BLADERF_ERR_INVAL for an invalid frequency,\n         or a value from \\ref RETCODES list on other failures"]
    pub fn bladerf_set_smb_frequency(
        dev: *mut bladerf,
        rate: u32,
        actual: *mut u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read the SMB connector output frequency in rational Hz\n\n @param       dev         Device handle\n @param[out]  rate        Pointer to returned rational frequency\n\n @return 0 on success, value from \\ref RETCODES list upon failure"]
    pub fn bladerf_get_rational_smb_frequency(
        dev: *mut bladerf,
        rate: *mut bladerf_rational_rate,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read the SMB connector output frequency in Hz\n\n @param       dev         Device handle\n @param[out]  rate        Pointer to returned frequency\n\n @return 0 on success, value from \\ref RETCODES list upon failure"]
    pub fn bladerf_get_smb_frequency(dev: *mut bladerf, rate: *mut ::libc::c_uint)
        -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read the state of expansion GPIO values\n\n @param       dev         Device handle\n @param[out]  val         Value of GPIO pins\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_expansion_gpio_read(dev: *mut bladerf, val: *mut u32) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write expansion GPIO pins.\n\n Callers should be sure to perform a read-modify-write sequence to avoid\n accidentally clearing other GPIO bits that may be set by the library\n internally.\n\n Consider using bladerf_expansion_gpio_masked_write() instead.\n\n @param       dev     Device handle\n @param[in]   val     Data to write to GPIO pins\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_expansion_gpio_write(dev: *mut bladerf, val: u32) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write values to the specified GPIO pins\n\n This function alleviates the need for the caller to perform a\n read-modify-write sequence. The supplied mask is used by the FPGA to perform\n the required RMW operation.\n\n @param       dev     Device handle\n @param[in]   mask    Mask of pins to write\n @param[in]   value   Value to write.\n\n For example, to set XB200 pins J16-1 and J16-2, and clear J16-4 and J16-5:\n\n @code{.c}\n  const uint32_t pins_to_write =\n      BLADERF_XB200_PIN_J16_1 |\n      BLADERF_XB200_PIN_J16_2 |\n      BLADERF_XB200_PIN_J16_3 |\n      BLADERF_XB200_PIN_J16_4;\n\n  const uint32_t values_to_write =\n      BLADERF_XB200_PIN_J16_1 |\n      BLADERF_XB200_PIN_J16_2;\n\n  int status = bladerf_expansion_gpio_masked_write(dev,\n                                                   pins_to_write,\n                                                   values_to_write);\n @endcode\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_expansion_gpio_masked_write(
        dev: *mut bladerf,
        mask: u32,
        value: u32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read the expansion GPIO direction register\n\n @param       dev         Device handle\n @param[out]  outputs     Pins configured as outputs will be set to '1'.\n                          Pins configured as inputs will be set to '0'.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_expansion_gpio_dir_read(dev: *mut bladerf, outputs: *mut u32) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write to the expansion GPIO direction register.\n\n Callers should be sure to perform a read-modify-write sequence to avoid\n accidentally clearing other GPIO bits that may be set by the library\n internally.\n\n Consider using bladerf_expansion_gpio_dir_masked_write() instead.\n\n @param       dev         Device handle\n @param[in]   outputs     Pins set to '1' will be configured as outputs.\n                          Pins set to '0' will be configured as inputs.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_expansion_gpio_dir_write(dev: *mut bladerf, outputs: u32) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Configure the direction of the specified expansion GPIO pins\n\n This function alleviates the need for the caller to perform a\n read-modify-write sequence. The supplied mask is used by the FPGA to perform\n the required RMW operation.\n\n @param       dev         Device handle\n @param[in]   mask        Bitmask of pins to configure\n @param[in]   outputs     Pins set to '1' will be configured as outputs.\n                          Pins set to '0' will be configured as inputs.\n\n For example, to configure XB200 pins J16-1 and J16-2 and pins J16-4 and J16-5\n as inputs:\n\n @code{.c}\n  const uint32_t pins_to_config =\n      BLADERF_XB200_PIN_J16_1 |\n      BLADERF_XB200_PIN_J16_2 |\n      BLADERF_XB200_PIN_J16_3 |\n      BLADERF_XB200_PIN_J16_4;\n\n  const uint32_t output_pins =\n      BLADERF_XB200_PIN_J16_1 |\n      BLADERF_XB200_PIN_J16_2;\n\n  int status = bladerf_expansion_gpio_masked_write(dev,\n                                                   pins_to_config,\n                                                   output_pins);\n @endcode\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_expansion_gpio_dir_masked_write(
        dev: *mut bladerf,
        mask: u32,
        outputs: u32,
    ) -> ::libc::c_int;
}
#[doc = " 50-54 MHz (6 meter band) filterbank"]
pub const bladerf_xb200_filter_BLADERF_XB200_50M: bladerf_xb200_filter = 0;
#[doc = " 144-148 MHz (2 meter band) filterbank"]
pub const bladerf_xb200_filter_BLADERF_XB200_144M: bladerf_xb200_filter = 1;
#[doc = " 222-225 MHz (1.25 meter band) filterbank.\n\n Note that this filter option is technically wider, covering 206-235 MHz."]
pub const bladerf_xb200_filter_BLADERF_XB200_222M: bladerf_xb200_filter = 2;
#[doc = " This option enables the RX/TX channel's custom filter bank path across\n the associated FILT and FILT-ANT SMA connectors on the XB-200 board.\n\n For reception, it is often possible to simply connect the RXFILT and\n RXFILT-ANT connectors with an SMA cable (effectively, \"no filter\"). This\n allows for reception of signals outside of the frequency range of the\n on-board filters, with some potential trade-off in signal quality.\n\n For transmission, <b>always</b> use an appropriate filter on the custom\n filter path to avoid spurious emissions.\n"]
pub const bladerf_xb200_filter_BLADERF_XB200_CUSTOM: bladerf_xb200_filter = 3;
#[doc = " When this option is selected, the other filter options are automatically\n selected depending on the RX or TX channel's current frequency, based\n upon the 1dB points of the on-board filters.  For frequencies outside\n the range of the on-board filters, the custom path is selected."]
pub const bladerf_xb200_filter_BLADERF_XB200_AUTO_1DB: bladerf_xb200_filter = 4;
#[doc = " When this option is selected, the other filter options are automatically\n selected depending on the RX or TX channel's current frequency, based\n upon the 3dB points of the on-board filters. For frequencies outside the\n range of the on-board filters, the custom path is selected."]
pub const bladerf_xb200_filter_BLADERF_XB200_AUTO_3DB: bladerf_xb200_filter = 5;
#[doc = " XB-200 filter selection options"]
pub type bladerf_xb200_filter = ::libc::c_uint;
#[doc = "< Bypass the XB-200 mixer"]
pub const bladerf_xb200_path_BLADERF_XB200_BYPASS: bladerf_xb200_path = 0;
#[doc = "< Pass signals through the XB-200 mixer"]
pub const bladerf_xb200_path_BLADERF_XB200_MIX: bladerf_xb200_path = 1;
#[doc = " XB-200 signal paths"]
pub type bladerf_xb200_path = ::libc::c_uint;
#[doc = "< Invalid TRX selection"]
pub const bladerf_xb300_trx_BLADERF_XB300_TRX_INVAL: bladerf_xb300_trx = -1;
#[doc = "< TRX antenna operates as TX"]
pub const bladerf_xb300_trx_BLADERF_XB300_TRX_TX: bladerf_xb300_trx = 0;
#[doc = "< TRX antenna operates as RX"]
pub const bladerf_xb300_trx_BLADERF_XB300_TRX_RX: bladerf_xb300_trx = 1;
#[doc = "< TRX antenna unset"]
pub const bladerf_xb300_trx_BLADERF_XB300_TRX_UNSET: bladerf_xb300_trx = 2;
#[doc = " XB-300 TRX setting"]
pub type bladerf_xb300_trx = ::libc::c_int;
#[doc = "< Invalid amplifier selection"]
pub const bladerf_xb300_amplifier_BLADERF_XB300_AMP_INVAL: bladerf_xb300_amplifier = -1;
#[doc = "< TX Power amplifier"]
pub const bladerf_xb300_amplifier_BLADERF_XB300_AMP_PA: bladerf_xb300_amplifier = 0;
#[doc = "< RX LNA"]
pub const bladerf_xb300_amplifier_BLADERF_XB300_AMP_LNA: bladerf_xb300_amplifier = 1;
#[doc = "< Auxillary Power amplifier"]
pub const bladerf_xb300_amplifier_BLADERF_XB300_AMP_PA_AUX: bladerf_xb300_amplifier = 2;
#[doc = " XB-300 Amplifier selection"]
pub type bladerf_xb300_amplifier = ::libc::c_int;
extern "C" {
    #[doc = " Set XB-200 filterbank\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   filter      XB200 filterbank\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_xb200_set_filterbank(
        dev: *mut bladerf,
        ch: bladerf_channel,
        filter: bladerf_xb200_filter,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get current XB-200 filterbank\n\n @param        dev        Device handle\n @param[in]    ch         Channel\n @param[out]   filter     Pointer to filterbank, only updated if return\n                          value is 0.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_xb200_get_filterbank(
        dev: *mut bladerf,
        ch: bladerf_channel,
        filter: *mut bladerf_xb200_filter,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set XB-200 signal path\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[in]   path        Desired XB-200 signal path\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_xb200_set_path(
        dev: *mut bladerf,
        ch: bladerf_channel,
        path: bladerf_xb200_path,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get current XB-200 signal path\n\n @param       dev         Device handle\n @param[in]   ch          Channel\n @param[out]  path        Pointer to XB200 signal path\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_xb200_get_path(
        dev: *mut bladerf,
        ch: bladerf_channel,
        path: *mut bladerf_xb200_path,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Configure the XB-300 TRX path\n\n @param       dev         Device handle\n @param[in]   trx         Desired XB-300 TRX setting\n\n @return 0 on success, BLADERF_ERR_* on failure"]
    pub fn bladerf_xb300_set_trx(dev: *mut bladerf, trx: bladerf_xb300_trx) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the current XB-300 signal path\n\n @param       dev         Device handle\n @param[out]  trx         XB300 TRX antenna setting\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_xb300_get_trx(dev: *mut bladerf, trx: *mut bladerf_xb300_trx) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Enable or disable selected XB-300 amplifier\n\n @param       dev         Device handle\n @param[in]   amp         XB-300 amplifier\n @param[in]   enable      Set true to enable or false to disable\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_xb300_set_amplifier_enable(
        dev: *mut bladerf,
        amp: bladerf_xb300_amplifier,
        enable: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get state of selected XB-300 amplifier\n\n @param       dev         Device handle\n @param[in]   amp         XB-300 amplifier\n @param[out]  enable      Set true to enable or false to disable\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_xb300_get_amplifier_enable(
        dev: *mut bladerf,
        amp: bladerf_xb300_amplifier,
        enable: *mut bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get current PA PDET output power in dBm\n\n @param       dev         Device handle\n @param[out]  val         Output power in dBm\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_xb300_get_output_power(dev: *mut bladerf, val: *mut f32) -> ::libc::c_int;
}
pub const bladerf_cal_module_BLADERF_DC_CAL_INVALID: bladerf_cal_module = -1;
pub const bladerf_cal_module_BLADERF_DC_CAL_LPF_TUNING: bladerf_cal_module = 0;
pub const bladerf_cal_module_BLADERF_DC_CAL_TX_LPF: bladerf_cal_module = 1;
pub const bladerf_cal_module_BLADERF_DC_CAL_RX_LPF: bladerf_cal_module = 2;
pub const bladerf_cal_module_BLADERF_DC_CAL_RXVGA2: bladerf_cal_module = 3;
#[doc = " DC Calibration Modules"]
pub type bladerf_cal_module = ::libc::c_int;
extern "C" {
    #[doc = " Perform DC calibration\n\n @param       dev         Device handle\n @param[in]   module      Module to calibrate\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_calibrate_dc(dev: *mut bladerf, module: bladerf_cal_module) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write value to VCTCXO trim DAC.\n\n \\deprecated Use bladerf_trim_dac_write().\n\n This should not be used when the VCTCXO tamer is enabled.\n\n @param       dev     Device handle\n @param[in]   val     Value to write to VCTCXO trim DAC\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_dac_write(dev: *mut bladerf, val: u16) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read value from VCTCXO trim DAC.\n\n \\deprecated Use bladerf_trim_dac_read().\n\n This is similar to bladerf_get_vctcxo_trim(), except that it returns the\n current trim DAC value, as opposed to the calibration value read from flash.\n\n Use this if you are trying to query the value after having previously made\n calls to bladerf_dac_write().\n\n @param       dev     Device handle\n @param[out]  val     Value to read from VCTCXO trim DAC\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_dac_read(dev: *mut bladerf, val: *mut u16) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read a Si5338 register\n\n @param       dev         Device handle\n @param[in]   address     Si5338 register address\n @param[out]  val         Register value\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_si5338_read(dev: *mut bladerf, address: u8, val: *mut u8) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write a Si5338 register\n\n @param       dev         Device handle\n @param[in]   address     Si5338 register address\n @param[in]   val         Value to write to register\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_si5338_write(dev: *mut bladerf, address: u8, val: u8) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read a LMS register\n\n @param       dev         Device handle\n @param[in]   address     LMS register address\n @param[out]  val         Register value\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_lms_read(dev: *mut bladerf, address: u8, val: *mut u8) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write a LMS register\n\n @param       dev         Device handle\n @param[in]   address     LMS register address\n @param[in]   val         Value to write to register\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_lms_write(dev: *mut bladerf, address: u8, val: u8) -> ::libc::c_int;
}
#[doc = " This structure is used to directly apply DC calibration register values to\n the LMS, rather than use the values resulting from an auto-calibration.\n\n A value < 0 is used to denote that the specified value should not be written.\n If a value is to be written, it will be truncated to 8-bits."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_lms_dc_cals {
    #[doc = "< LPF tuning module"]
    pub lpf_tuning: i16,
    #[doc = "< TX LPF I filter"]
    pub tx_lpf_i: i16,
    #[doc = "< TX LPF Q filter"]
    pub tx_lpf_q: i16,
    #[doc = "< RX LPF I filter"]
    pub rx_lpf_i: i16,
    #[doc = "< RX LPF Q filter"]
    pub rx_lpf_q: i16,
    #[doc = "< RX VGA2 DC reference module"]
    pub dc_ref: i16,
    #[doc = "< RX VGA2, I channel of first gain stage"]
    pub rxvga2a_i: i16,
    #[doc = "< RX VGA2, Q channel of first gain stage"]
    pub rxvga2a_q: i16,
    #[doc = "< RX VGA2, I channel of second gain stage"]
    pub rxvga2b_i: i16,
    #[doc = "< RX VGA2, Q channel of second gain stage"]
    pub rxvga2b_q: i16,
}
#[test]
fn bindgen_test_layout_bladerf_lms_dc_cals() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_lms_dc_cals> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_lms_dc_cals>(),
        20usize,
        concat!("Size of: ", stringify!(bladerf_lms_dc_cals))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_lms_dc_cals>(),
        2usize,
        concat!("Alignment of ", stringify!(bladerf_lms_dc_cals))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lpf_tuning) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_lms_dc_cals),
            "::",
            stringify!(lpf_tuning)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_lpf_i) as usize - ptr as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_lms_dc_cals),
            "::",
            stringify!(tx_lpf_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx_lpf_q) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_lms_dc_cals),
            "::",
            stringify!(tx_lpf_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_lpf_i) as usize - ptr as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_lms_dc_cals),
            "::",
            stringify!(rx_lpf_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx_lpf_q) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_lms_dc_cals),
            "::",
            stringify!(rx_lpf_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).dc_ref) as usize - ptr as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_lms_dc_cals),
            "::",
            stringify!(dc_ref)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxvga2a_i) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_lms_dc_cals),
            "::",
            stringify!(rxvga2a_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxvga2a_q) as usize - ptr as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_lms_dc_cals),
            "::",
            stringify!(rxvga2a_q)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxvga2b_i) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_lms_dc_cals),
            "::",
            stringify!(rxvga2b_i)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rxvga2b_q) as usize - ptr as usize },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_lms_dc_cals),
            "::",
            stringify!(rxvga2b_q)
        )
    );
}
extern "C" {
    #[doc = " Manually load values into LMS6002 DC calibration registers.\n\n This is generally intended for applying a set of known values resulting from\n a previous run of the LMS autocalibrations.\n\n @param       dev        Device handle\n @param[in]   dc_cals    Calibration values to load. Values set to <0 will\n                          not be applied.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_lms_set_dc_cals(
        dev: *mut bladerf,
        dc_cals: *const bladerf_lms_dc_cals,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Retrieve the current DC calibration values from the LMS6002\n\n @param       dev        Device handle\n @param[out]  dc_cals    Populated with current values\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_lms_get_dc_cals(
        dev: *mut bladerf,
        dc_cals: *mut bladerf_lms_dc_cals,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write value to secondary XB SPI\n\n @param       dev     Device handle\n @param[out]  val     Value to write to XB SPI\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_xb_spi_write(dev: *mut bladerf, val: u32) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get current bias tee state\n\n @param       dev     Device handle\n @param[in]   ch      Channel\n @param[out]  enable  True if bias tee active, false otherwise\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_bias_tee(
        dev: *mut bladerf,
        ch: bladerf_channel,
        enable: *mut bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get current bias tee state\n\n @param       dev     Device handle\n @param[in]   ch      Channel\n @param[in]   enable  True to activate bias tee, false to deactivate\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_bias_tee(
        dev: *mut bladerf,
        ch: bladerf_channel,
        enable: bool,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read a RFIC register\n\n @param       dev         Device handle\n @param[in]   address     Register address\n @param[out]  val         Register value\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_rfic_register(
        dev: *mut bladerf,
        address: u16,
        val: *mut u8,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write a RFIC register\n\n @param       dev         Device handle\n @param[in]   address     Register address\n @param[in]   val         Value to write to register\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_rfic_register(dev: *mut bladerf, address: u16, val: u8) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read the temperature from the RFIC\n\n @param       dev         Device handle\n @param[out]  val         Temperature in degrees C\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_rfic_temperature(dev: *mut bladerf, val: *mut f32) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read the RSSI for the selected channel from the RFIC\n\n @note  This is a relative value, not an absolute value. If an absolute\n        value (e.g. in dBm) is desired, a calibration should be performed\n        against a reference signal.\n\n @note  See `fpga_common/src/ad936x_params.c` for the RSSI control parameters.\n\n Reference: AD9361 Reference Manual UG-570\n\n @param       dev         Device handle\n @param       ch          Channel to query\n @param[out]  pre_rssi    Preamble RSSI in dB (first calculated RSSI result)\n @param[out]  sym_rssi    Symbol RSSI in dB (most recent RSSI result)\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_rfic_rssi(
        dev: *mut bladerf,
        ch: bladerf_channel,
        pre_rssi: *mut i32,
        sym_rssi: *mut i32,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read the CTRL_OUT pins from the RFIC\n\n @note  See AD9361 Reference Manual UG-570's \"Control Output\" chapter for\n        complete information about this feature.\n\n @see   bladerf_set_rfic_register()\n\n @param      dev       Device handle\n @param[out] ctrl_out  Pointer for storing the retrieved value\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_rfic_ctrl_out(dev: *mut bladerf, ctrl_out: *mut u8) -> ::libc::c_int;
}
#[doc = "< No filter"]
pub const bladerf_rfic_rxfir_BLADERF_RFIC_RXFIR_BYPASS: bladerf_rfic_rxfir = 0;
#[doc = "< Custom FIR filter (currently unused)"]
pub const bladerf_rfic_rxfir_BLADERF_RFIC_RXFIR_CUSTOM: bladerf_rfic_rxfir = 1;
#[doc = "< Decimate by 1 (default)"]
pub const bladerf_rfic_rxfir_BLADERF_RFIC_RXFIR_DEC1: bladerf_rfic_rxfir = 2;
#[doc = "< Decimate by 2"]
pub const bladerf_rfic_rxfir_BLADERF_RFIC_RXFIR_DEC2: bladerf_rfic_rxfir = 3;
#[doc = "< Decimate by 4"]
pub const bladerf_rfic_rxfir_BLADERF_RFIC_RXFIR_DEC4: bladerf_rfic_rxfir = 4;
#[doc = " RFIC RX FIR filter choices"]
pub type bladerf_rfic_rxfir = ::libc::c_uint;
#[doc = "< No filter (default)"]
pub const bladerf_rfic_txfir_BLADERF_RFIC_TXFIR_BYPASS: bladerf_rfic_txfir = 0;
#[doc = "< Custom FIR filter (currently unused)"]
pub const bladerf_rfic_txfir_BLADERF_RFIC_TXFIR_CUSTOM: bladerf_rfic_txfir = 1;
#[doc = "< Interpolate by 1"]
pub const bladerf_rfic_txfir_BLADERF_RFIC_TXFIR_INT1: bladerf_rfic_txfir = 2;
#[doc = "< Interpolate by 2"]
pub const bladerf_rfic_txfir_BLADERF_RFIC_TXFIR_INT2: bladerf_rfic_txfir = 3;
#[doc = "< Interpolate by 4"]
pub const bladerf_rfic_txfir_BLADERF_RFIC_TXFIR_INT4: bladerf_rfic_txfir = 4;
#[doc = " RFIC TX FIR filter choices"]
pub type bladerf_rfic_txfir = ::libc::c_uint;
extern "C" {
    #[doc = " Get the current status of the RX FIR filter on the RFIC.\n\n @param   dev     Device handle\n @param   rxfir   RX FIR selection\n\n @note  See `fpga_common/src/ad936x_params.c` for FIR parameters.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_rfic_rx_fir(
        dev: *mut bladerf,
        rxfir: *mut bladerf_rfic_rxfir,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the RX FIR filter on the RFIC.\n\n @param   dev     Device handle\n @param   rxfir   RX FIR selection\n\n @note  See `fpga_common/src/ad936x_params.c` for FIR parameters.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_rfic_rx_fir(dev: *mut bladerf, rxfir: bladerf_rfic_rxfir) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the current status of the TX FIR filter on the RFIC.\n\n @param   dev     Device handle\n @param   txfir   TX FIR selection\n\n @note  See `fpga_common/src/ad936x_params.c` for FIR parameters.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_rfic_tx_fir(
        dev: *mut bladerf,
        txfir: *mut bladerf_rfic_txfir,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the TX FIR filter on the RFIC.\n\n @param   dev     Device handle\n @param   txfir   TX FIR selection\n\n @note  See `fpga_common/src/ad936x_params.c` for FIR parameters.\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_rfic_tx_fir(dev: *mut bladerf, txfir: bladerf_rfic_txfir) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Fetch the lock state of the Phase Detector/Frequency Synthesizer\n\n @param       dev         Device handle\n @param[out]  locked      True if locked, False otherwise\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_pll_lock_state(dev: *mut bladerf, locked: *mut bool) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Fetch the state of the Phase Detector/Frequency Synthesizer\n\n @param       dev         Device handle\n @param[out]  enabled     True if enabled, False otherwise\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_pll_enable(dev: *mut bladerf, enabled: *mut bool) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Enable the Phase Detector/Frequency Synthesizer\n\n Enabling this disables the VCTCXO trimmer DAC, and vice versa.\n\n @param       dev         Device handle\n @param[in]   enable      True to enable, False otherwise\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_pll_enable(dev: *mut bladerf, enable: bool) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the valid range of frequencies for the reference clock input\n\n @param       dev         Device handle\n @param[out]  range       Reference clock frequency range\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_pll_refclk_range(
        dev: *mut bladerf,
        range: *mut *const bladerf_range,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the currently-configured frequency for the reference clock\n input.\n\n @param       dev         Device handle\n @param[out]  frequency   Reference clock frequency\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_pll_refclk(dev: *mut bladerf, frequency: *mut u64) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the expected frequency for the reference clock input.\n\n @param       dev         Device handle\n @param[in]   frequency   Reference clock frequency\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_pll_refclk(dev: *mut bladerf, frequency: u64) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Read value from Phase Detector/Frequency Synthesizer\n\n The `address` is interpreted as the control bits (DB1 and DB0) used to write\n to a specific latch.\n\n @param       dev         Device handle\n @param[in]   address     Latch address\n @param[out]  val         Value to read from\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_pll_register(dev: *mut bladerf, address: u8, val: *mut u32)
        -> ::libc::c_int;
}
extern "C" {
    #[doc = " Write value to Phase Detector/Frequency Synthesizer\n\n The `address` is interpreted as the control bits (DB1 and DB0) used to write\n to a specific latch.  These bits are masked out in `val`\n\n @param       dev         Device handle\n @param[in]   address     Latch address\n @param[in]   val         Value to write to\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_pll_register(dev: *mut bladerf, address: u8, val: u32) -> ::libc::c_int;
}
#[doc = "< Unknown; manual observation may be required"]
pub const bladerf_power_sources_BLADERF_UNKNOWN: bladerf_power_sources = 0;
#[doc = "< DC Barrel Plug"]
pub const bladerf_power_sources_BLADERF_PS_DC: bladerf_power_sources = 1;
#[doc = "< USB Bus"]
pub const bladerf_power_sources_BLADERF_PS_USB_VBUS: bladerf_power_sources = 2;
#[doc = " Power sources"]
pub type bladerf_power_sources = ::libc::c_uint;
extern "C" {
    #[doc = " Get the active power source reported by the power multiplexer\n\n Reference: http://www.ti.com/product/TPS2115A\n\n @param       dev     Device handle\n @param[out]  val     Value read from power multiplexer\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_power_source(
        dev: *mut bladerf,
        val: *mut bladerf_power_sources,
    ) -> ::libc::c_int;
}
#[doc = "< Use onboard VCTCXO"]
pub const bladerf_clock_select_CLOCK_SELECT_ONBOARD: bladerf_clock_select = 0;
#[doc = "< Use external clock input"]
pub const bladerf_clock_select_CLOCK_SELECT_EXTERNAL: bladerf_clock_select = 1;
#[doc = " Available clock sources"]
pub type bladerf_clock_select = ::libc::c_uint;
extern "C" {
    #[doc = " Get the selected clock source\n\n Reference: https://www.silabs.com/documents/public/data-sheets/Si53304.pdf\n\n @param       dev     Device handle\n @param[out]  sel     Clock input source currently in use\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_clock_select(
        dev: *mut bladerf,
        sel: *mut bladerf_clock_select,
    ) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the clock source\n\n Reference: https://www.silabs.com/documents/public/data-sheets/Si53304.pdf\n\n @param       dev     Device handle\n @param[in]   sel     Clock input source to use\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_clock_select(dev: *mut bladerf, sel: bladerf_clock_select) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Get the current state of the clock output\n\n @param       dev     Device handle\n @param[out]  state   Clock output state\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_clock_output(dev: *mut bladerf, state: *mut bool) -> ::libc::c_int;
}
extern "C" {
    #[doc = " Set the clock output (enable/disable)\n\n @param       dev     Device handle\n @param[in]   enable  Clock output enable\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_set_clock_output(dev: *mut bladerf, enable: bool) -> ::libc::c_int;
}
#[doc = "< Configuration register (uint16_t)"]
pub const bladerf_pmic_register_BLADERF_PMIC_CONFIGURATION: bladerf_pmic_register = 0;
#[doc = "< Shunt voltage (float)"]
pub const bladerf_pmic_register_BLADERF_PMIC_VOLTAGE_SHUNT: bladerf_pmic_register = 1;
#[doc = "< Bus voltage (float)"]
pub const bladerf_pmic_register_BLADERF_PMIC_VOLTAGE_BUS: bladerf_pmic_register = 2;
#[doc = "< Load power (float)"]
pub const bladerf_pmic_register_BLADERF_PMIC_POWER: bladerf_pmic_register = 3;
#[doc = "< Load current (float)"]
pub const bladerf_pmic_register_BLADERF_PMIC_CURRENT: bladerf_pmic_register = 4;
#[doc = "< Calibration (uint16_t)"]
pub const bladerf_pmic_register_BLADERF_PMIC_CALIBRATION: bladerf_pmic_register = 5;
#[doc = " Register identifiers for PMIC"]
pub type bladerf_pmic_register = ::libc::c_uint;
extern "C" {
    #[doc = " Read value from Power Monitor IC\n\n Reference: http://www.ti.com/product/INA219\n\n @param       dev     Device handle\n @param[in]   reg     Register to read from\n @param[out]  val     Value read from PMIC\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_pmic_register(
        dev: *mut bladerf,
        reg: bladerf_pmic_register,
        val: *mut ::libc::c_void,
    ) -> ::libc::c_int;
}
#[doc = " RF switch configuration structure"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct bladerf_rf_switch_config {
    #[doc = "< Active TX1 output from RFIC"]
    pub tx1_rfic_port: u32,
    #[doc = "< RF switch configuration for the TX1 path"]
    pub tx1_spdt_port: u32,
    #[doc = "< Active TX2 output from RFIC"]
    pub tx2_rfic_port: u32,
    #[doc = "< RF switch configuration for the TX2 path"]
    pub tx2_spdt_port: u32,
    #[doc = "< Active RX1 input to RFIC"]
    pub rx1_rfic_port: u32,
    #[doc = "< RF switch configuration for the RX1 path"]
    pub rx1_spdt_port: u32,
    #[doc = "< Active RX2 input to RFIC"]
    pub rx2_rfic_port: u32,
    #[doc = "< RF switch configuration for the RX2 path"]
    pub rx2_spdt_port: u32,
}
#[test]
fn bindgen_test_layout_bladerf_rf_switch_config() {
    const UNINIT: ::std::mem::MaybeUninit<bladerf_rf_switch_config> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<bladerf_rf_switch_config>(),
        32usize,
        concat!("Size of: ", stringify!(bladerf_rf_switch_config))
    );
    assert_eq!(
        ::std::mem::align_of::<bladerf_rf_switch_config>(),
        4usize,
        concat!("Alignment of ", stringify!(bladerf_rf_switch_config))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx1_rfic_port) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_rf_switch_config),
            "::",
            stringify!(tx1_rfic_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx1_spdt_port) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_rf_switch_config),
            "::",
            stringify!(tx1_spdt_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx2_rfic_port) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_rf_switch_config),
            "::",
            stringify!(tx2_rfic_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).tx2_spdt_port) as usize - ptr as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_rf_switch_config),
            "::",
            stringify!(tx2_spdt_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx1_rfic_port) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_rf_switch_config),
            "::",
            stringify!(rx1_rfic_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx1_spdt_port) as usize - ptr as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_rf_switch_config),
            "::",
            stringify!(rx1_spdt_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx2_rfic_port) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_rf_switch_config),
            "::",
            stringify!(rx2_rfic_port)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).rx2_spdt_port) as usize - ptr as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(bladerf_rf_switch_config),
            "::",
            stringify!(rx2_spdt_port)
        )
    );
}
extern "C" {
    #[doc = " Read the current RF switching configuration from the bladeRF hardware.\n\n Queries both the RFIC and the RF switch and passes back a\n bladerf_rf_switch_config stucture.\n\n @param       dev     Device handle\n @param[out]  config  Switch configuration struct\n\n @return 0 on success, value from \\ref RETCODES list on failure"]
    pub fn bladerf_get_rf_switch_config(
        dev: *mut bladerf,
        config: *mut bladerf_rf_switch_config,
    ) -> ::libc::c_int;
}
pub type __builtin_va_list = *mut ::libc::c_char;
pub type __uint128_t = u128;
